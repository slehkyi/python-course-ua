[Зміст](../Contents.md) \| [Попередній розділ (2.3. Форматування)](03_Formatting.md) \| [Наступний розділ (2.5. Колекції)](05_Collections.md)

# 2.4 Послідовності
### Типи даних послідовностей

Python має три типи даних типу *послідовність*.

* Рядок: `'Привіт'`. Рядок — це послідовність символів.
* Список: `[1, 4, 5]`.
* Тапл: `('GOOG', 100, 490.1)`.

Усі послідовності впорядковані, проіндексовані цілими числами та мають довжину.

```python
a = 'Hello'               # Рядок
b = [1, 4, 5]             # Список
c = ('GOOG', 100, 490.1)  # Тапл

# Впорядковано за індексами
a[0]                      # 'H'
b[-1]                     # 5
c[1]                      # 100

# Довжина послідовности
len(a)                    # 5
len(b)                    # 3
len(c)                    # 3
```

Послідовності можна продублювати: `s * n`.

```python
>>> a = 'Hello'
>>> a * 3
'HelloHelloHello'
>>> b = [1, 2, 3]
>>> b * 2
[1, 2, 3, 1, 2, 3]
>>>
```

Послідовності одного типу можна об’єднувати: `s + t`.

```python
>>> a = (1, 2, 3)
>>> b = (4, 5)
>>> a + b
(1, 2, 3, 4, 5)
>>>
>>> c = [1, 5]
>>> a + c
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate tuple (not "list") to tuple
```

### Нарізка/розрізання

Розрізання означає взяти підпослідовність із послідовності. Синтаксис: `s[початок:кінець]`. Де "початок" і "кінець" — індекси потрібної підпослідовності.

```python
a = [0,1,2,3,4,5,6,7,8]

a[2:5]    # [2,3,4]
a[-5:]    # [4,5,6,7,8]
a[:3]     # [0,1,2]
```

* Індекси "початок" і "кінець" повинні бути цілими числами.
* Зрізи *не* включають кінцеве значення. Це як напіввідкритий інтервал із математики.
* Якщо індекси пропущені, за замовчуванням береться підпослідовність до початку або кінця списку.

### Перепризначення фрагментів

У списках фрагменти можна перепризначати та видаляти.

```python
# Перепризначення
a = [0,1,2,3,4,5,6,7,8]
a[2:4] = [10,11,12]       # [0,1,10,11,12,4,5,6,7,8]
```

*Примітка. Перепризначений фрагмент не обов’язково повинен мати ту ж саму довжину.*

```python
# Видалення
a = [0,1,2,3,4,5,6,7,8]
del a[2:4]                # [0,1,4,5,6,7,8]
```

### Скорочення послідовності

Існує кілька загальних функцій для зменшення послідовності до одного значення. Також це можна назвати групуванням.

```python
>>> s = [1, 2, 3, 4]
>>> sum(s)
10
>>> min(s)
1
>>> max(s)
4
>>> t = ['Hello', 'World']
>>> max(t)
'World'
>>>
```

### Ітерація по послідовності

Цикл `for` повторює елементи в послідовності.

```python
>>> s = [1, 4, 9, 16]
>>> for i in s:
...     print(i)
...
1
4
9
16
>>>
```

На кожній ітерації циклу ви отримуєте новий елемент для роботи. Це нове значення поміщається в змінну ітерації. У цьому прикладі змінною ітерації є `x`:
```python
for x in s:         # `x` - змінна ітерації
    ...statements
```

На кожній ітерації попереднє значення змінної ітерації перезаписується (якщо таке є). Після завершення циклу змінна зберігає останнє значення.

### Оператор break

Ви можете використовувати інструкцію `break`, щоб завчасно вийти з циклу.
```python
for name in namelist:
    if name == 'Jake':
        break
    ...
    ...
statements
```

Коли оператор `break` виконується, він виходить із циклу та переходить до наступних `statements`. Інструкція `break` застосовується лише до найбільш внутрішнього циклу. Якщо цей цикл знаходиться всередині іншого циклу, `break` не порушить зовнішній цикл.

### Оператор continue

Щоб пропустити один елемент і перейти до наступного, скористайтеся оператором `continue`.

```python
for line in lines:
    if line == '\n':    # Пропустити пустий рядок
        continue
    # Інші вирази/рядки коду
    ...
```

Це корисно, коли поточний елемент не представляє інтересу або його потрібно проігнорувати під час обробки.

### Цикл над цілими числами

Якщо вам потрібно порахувати, використовуйте `range()`.

```python
for i in range(100):
    # i = 0,1,...,99
```

Синтаксис - `range([start,] end [,step])`

```python
for i in range(100):
    # i = 0,1,...,99
for j in range(10,20):
    # j = 10,11,..., 19
for k in range(10,50,2):
    # k = 10,12,...,48
    # Зверніть увагу на те, як цикл використовує крок 2
```

* Кінцеве значення ніколи не включається. Метод відображає поведінку зрізів.
* `початок` необов'язковий. За замовчуванням `0`.
* `крок` необов'язковий. Типове значення `1`.
* `range()` обчислює значення за потреби. Він насправді не зберігає великий діапазон чисел.

### Функція enumerate().

Функція `enumerate` додає до ітерації додаткове значення лічильника.

```python
names = ['Elwood', 'Jake', 'Curtis']
for i, name in enumerate(names):
    # Цикл з i = 0, name = 'Elwood'
    # i = 1, name = 'Jake'
    # i = 2, name = 'Curtis'
```

Загальною формою є `enumerate(sequence [, start = 0])`. `початок` необов'язковий. Гарним прикладом використання `enumerate()` є відстеження номерів рядків під час читання файлу:
```python
with open(filename) as f:
    for lineno, line in enumerate(f, start=1):
        ...
```

Зрештою, `enumerate` - це просто гарне скорочення для:

```python
i = 0
for x in s:
    statements
    i += 1
```

Використання `enumerate` вимагає менше стукання пальцями по клавіатурі та працює трохи швидше.

### For і тапли

Ви можете виконувати ітерацію з кількома змінними ітерації.

```python
points = [
  (1, 4),(10, 40),(23, 14),(5, 6),(7, 8)
]
for x, y in points:
    #     Цикл з x = 1, y = 4
    #            x = 10, y = 40
    #            x = 23, y = 14
    #            ...
```

При використанні кількох змінних кожен тапл *розпаковується* в набір змінних ітерації. Кількість змінних має відповідати кількості елементів у кожному таплі.

### Функція zip().

Функція `zip` приймає кілька послідовностей і створює ітератор, який їх поєднує.

```python
columns = ['name', 'shares', 'price']
values = ['GOOG', 100, 490.1 ]
pairs = zip(columns, values)
# ('name','GOOG'), ('shares',100), ('price',490.1)
```

Щоб отримати результат, необхідно пройтися по послідовності циклом. Ви можете використовувати кілька змінних, щоб розпакувати тапли, як було показано раніше.

```python
for column, value in pairs:
    ...
```

Загальне використання `zip` - це створення пар ключ/значення для побудови словників.

```python
d = dict(zip(columns, values))
```

## Вправи

### Вправа 2.13: Лічимо

Спробуйте кілька основних прикладів підрахунку:

```python
>>> for n in range(10):            # Порахувати 0 ... 9
        print(n, end=' ')

0 1 2 3 4 5 6 7 8 9
>>> for n in range(10,0,-1):       # Порахувати 10 ... 1
        print(n, end=' ')

10 9 8 7 6 5 4 3 2 1
>>> for n in range(0,10,2):        # Порахувати 0, 2, ... 8
        print(n, end=' ')

0 2 4 6 8
>>>
```

### Вправа 2.14: Більше послідовних операцій

Інтерактивно поекспериментуйте з деякими операціями скорочення послідовності.
```python
>>> data = [4, 9, 1, 25, 16, 100, 49]
>>> min(data)
1
>>> max(data)
100
>>> sum(data)
204
>>>
```

Спробуйте циклічно переглянути дані.

```python
>>> for x in data:
        print(x)

4
9
...
>>> for n, x in enumerate(data):
        print(n, x)

0 4
1 9
2 1
...
>>>
```

Іноді новачки використовують оператори `for`, `len()` і `range()` у якомусь жахливому фрагменті коду, який, схоже, вийшов із глибин заржавілої програми на C.

```python
>>> for n in range(len(data)):
        print(data[n])

4
9
1
...
>>>
```

Не робіть цього! Мало того, що від читання цього коду у людей кровоточать очі, воно ще й працює з пам’яттю неефективно та взагалі набагато повільніше. Просто використовуйте звичайний цикл `for`, якщо ви хочете перебирати дані. Використовуйте `enumerate()`, якщо вам з якоїсь причини знадобився індекс.

### Вправа 2.15: Практичний приклад enumerate().

Згадайте, що файл `Data/missing.csv` містить дані для портфеля акцій, але містить деякі рядки з відсутніми даними. Використовуючи `enumerate()`, змініть свою програму `pcost.py` так, щоб вона друкувала номер рядка з попередженням у разі виявлення неправильного введення.

```python
>>> cost = portfolio_cost('Data/missing.csv')
Row 4: Couldn't convert: ['MSFT', '', '51.23']
Row 7: Couldn't convert: ['IBM', '', '70.44']
>>>
```

Для цього вам потрібно буде змінити кілька частин коду.

```python
...
for rowno, row in enumerate(rows, start=1):
    try:
        ...
    except ValueError:
        print(f'Row {rowno}: Bad row: {row}')
```

### Вправа 2.16: Використання функції zip().

У файлі `Data/portfolio.csv` перший рядок містить стовпець заголовків. У всьому попередньому коді ми їх відкидали.

```python
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> headers
['name', 'shares', 'price']
>>>
```

Але що, якби ви могли використати заголовки для чогось корисного? Ось тут і з’являється функція `zip()`. Спочатку спробуйте поєднати заголовки файлів із рядком даних:

```python
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>> list(zip(headers, row))
[ ('name', 'AA'), ('shares', '100'), ('price', '32.20') ]
>>>
```

Зверніть увагу, як `zip()` поєднав заголовки стовпців зі значеннями стовпців. Тут ми використали `list()`, щоб перетворити результат на список, щоб ви могли його бачити. Зазвичай `zip()` створює ітератор, який повинен використовуватися циклом `for`.

Це парування є проміжним кроком до створення словника. Тепер спробуйте наступне:
```python
>>> record = dict(zip(headers, row))
>>> record
{'price': '32.20', 'name': 'AA', 'shares': '100'}
>>>
```

Це перетворення є одним із найкорисніших трюків, які слід знати під час обробки великої кількості файлів даних. Наприклад, припустімо, що ви хочете змусити програму `pcost.py` працювати з різними вхідними файлами, але без урахування фактичного номера стовпця, де відображаються назва, акції та ціна.

Змініть функцію `portfolio_cost()` у `pcost.py` так, щоб вона виглядала так:

```python
# pcost.py

def portfolio_cost(filename):
    ...
        for rowno, row in enumerate(rows, start=1):
            record = dict(zip(headers, row))
            try:
                nshares = int(record['shares'])
                price = float(record['price'])
                total_cost += nshares * price
            # This catches errors in int() and float() conversions above
            except ValueError:
                print(f'Row {rowno}: Bad row: {row}')
        ...
```

Тепер спробуйте свою функцію на зовсім іншому файлі даних `Data/portfoliodate.csv`, який виглядає так:

```csv
name,date,time,shares,price
"AA","6/11/2007","9:50am",100,32.20
"IBM","5/13/2007","4:20pm",50,91.10
"CAT","9/23/2006","1:30pm",150,83.44
"MSFT","5/17/2007","10:30am",200,51.23
"GE","2/1/2006","10:45am",95,40.37
"MSFT","10/31/2006","12:05pm",50,65.10
"IBM","7/9/2006","3:15pm",100,70.44
```

```python
>>> portfolio_cost('Data/portfoliodate.csv')
44671.15
>>>
```

Якщо ви зробили все правильно, ви побачите, що ваша програма все ще працює, навіть якщо файл даних має зовсім інший формат стовпця, ніж раніше. Круто!

Зміни, зроблені тут, невеличкі, але значні. Замість того, щоб `portfolio_cost()` був жорстко закодований для читання одного фіксованого формату файлу, нова версія читає будь-який файл CSV і вибирає з нього потрібні значення. Поки у файлі є необхідні стовпці, код працюватиме.

Змініть програму `report.py`, яку ви написали в розділі 2.3, щоб вона використовувала ту саму техніку для вибору заголовків стовпців.

Спробуйте запустити програму `report.py` у файлі `Data/portfoliodate.csv` і переконайтеся, що вона дає ту саму відповідь, що й раніше.

### Вправа 2.17: Інвертування словника

Словник зіставляє ключі зі значеннями. Наприклад, словник біржових курсів.

```python
>>> prices = {
        'GOOG' : 490.1,
        'AA' : 23.45,
        'IBM' : 91.1,
        'MSFT' : 34.23
    }
>>>
```

Якщо ви використовуєте метод `items()`, ви можете отримати пари `(ключ, значення)`:

```python
>>> prices.items()
dict_items([('GOOG', 490.1), ('AA', 23.45), ('IBM', 91.1), ('MSFT', 34.23)])
>>>
```

Але що, якби ви замість цього хотіли отримати список пар `(значення, ключ)`? *Підказка: використовуйте `zip()`.*
```python
>>> pricelist = list(zip(prices.values(),prices.keys()))
>>> pricelist
[(490.1, 'GOOG'), (23.45, 'AA'), (91.1, 'IBM'), (34.23, 'MSFT')]
>>>
```

Навіщо вам це робити? По-перше, це дозволяє виконувати певні види обробки даних словника.
```python
>>> min(pricelist)
(23.45, 'AA')
>>> max(pricelist)
(490.1, 'GOOG')
>>> sorted(pricelist)
[(23.45, 'AA'), (34.23, 'MSFT'), (91.1, 'IBM'), (490.1, 'GOOG')]
>>>
```

Це також ілюструє важливу особливість кортежів. При використанні для порівнянь кортежі порівнюються поелементно, починаючи з першого елемента. Подібно до того, як рядки порівнюються посимвольно.

`zip()` часто використовується в таких ситуаціях, коли потрібно об’єднати дані з різних місць. Наприклад, поєднання імен стовпців зі значеннями стовпців, щоб створити словник іменованих значень.

Зауважте, що `zip()` не обмежується парами. Наприклад, ви можете використовувати його з будь-якою кількістю вхідних списків:

```python
>>> a = [1, 2, 3, 4]
>>> b = ['w', 'x', 'y', 'z']
>>> c = [0.2, 0.4, 0.6, 0.8]
>>> list(zip(a, b, c))
[(1, 'w', 0.2), (2, 'x', 0.4), (3, 'y', 0.6), (4, 'z', 0.8))]
>>>
```

Також майте на увазі, що `zip()` зупиняється, коли вичерпується найкоротша послідовність введення.

```python
>>> a = [1, 2, 3, 4, 5, 6]
>>> b = ['x', 'y', 'z']
>>> list(zip(a,b))
[(1, 'x'), (2, 'y'), (3, 'z')]
>>>
```

[Зміст](../Contents.md) \| [Попередній розділ (2.3. Форматування)](03_Formatting.md) \| [Наступний розділ (2.5. Колекції)](05_Collections.md)
