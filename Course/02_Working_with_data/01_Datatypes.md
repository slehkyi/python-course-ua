[Зміст](../Contents.md) \| [Попередній розділ (1.7. Функції)](../01_Introduction/07_Functions.md) \| [Наступний розділ (2.2. Контейнери)](02_Containers.md)

# 2.1 Типи і структури даних

У цьому розділі представлені структури даних у вигляді таплів і словників.

### Примітивні типи даних

Python має кілька примітивних типів даних:

* Цілі числа
* Числа з плаваючою комою
* Рядки (текст)

Про них ми дізналися у вступі.

### None тип
```python
email_address = None
```

`None` часто використовується як заповнювач для необов'язкового або відсутнього значення. Оцінюється як `False` в умовних виразах.
```python
if email_address:
    send_email(email_address, msg)
```

### Структури даних

Реальні програми мають більш складні дані. Наприклад, інформація про акції:
```code
100 shares of GOOG at $490.10
```
Це «об’єкт» із трьох частин:

* Назва або символ акції ("GOOG", рядок)
* Кількість акцій (100, ціле число)
* Ціна (490,10 число з плаваючою комою)

### Тапли

Тапл — це набір значень, згрупованих разом.

Наприклад:
```python
s = ('GOOG', 100, 490.1)
```

Іноді `()` опускаються в синтаксисі.
```python
s = 'GOOG', 100, 490.1
```

Особливі випадки (0-тапл, 1-тапл).
```python
t = ()            # Пустий тапл
w = ('GOOG', )    # Тапл з одним елементом
```

Тапли часто використовуються для представлення *простих* записів або структур. Як правило, це один *об'єкт* з кількох частин. Хороша аналогія: * Тапл схожий на один рядок у таблиці бази даних.*

Вміст таплів упорядкований (як масиви).
```python
s = ('GOOG', 100, 490.1)
name = s[0]                 # 'GOOG'
shares = s[1]               # 100
price = s[2]                # 490.1
```
Однак вміст не можна змінити.
```python
>>> s[1] = 75
TypeError: object does not support item assignment
```
Однак ви можете створити новий тапл на основі поточного таплу.
```python
s = (s[0], 75, s[2])
```

### Упаковка таплів
Тапли – це більше про упаковку пов’язаних елементів разом в одну *сутність*.
```python
s = ('GOOG', 100, 490.1)
```
Потім тапл легко передати іншим частинам програми як єдиний об’єкт.

### Розпакування кортежу

Щоб використовувати тапл деінде, ви можете розпакувати його частини у змінні.
```python
name, shares, price = s
print('Cost', shares * price)
```
Кількість змінних зліва має відповідати структурі таплу.
```python
name, shares = s     # ERROR
Traceback (most recent call last):
...
ValueError: too many values to unpack
```

### Тапли та списки

Тапли виглядають як списки лише для читання. Однак найчастіше тапли використовуються як *один елемент*, що складається з кількох частин. Списки зазвичай - це колекція різних елементів, як правило, одного типу.
```python
record = ('GOOG', 100, 490.1)       # A tuple representing a record in a portfolio

symbols = [ 'GOOG', 'AAPL', 'IBM' ]  # A List representing three stock symbols
```

### Словники
Словник – це зіставлення ключів зі значеннями. Його також іноді називають хеш-таблицею або асоціативним масивом. Ключі служать індексами для доступу до значень.
```python
s = {
    'name': 'GOOG',
    'shares': 100,
    'price': 490.1
}
```

### Поширені операції
Щоб отримати значення зі словника, використовуйте назви ключів.
```python
>>> print(s['name'], s['shares'])
GOOG 100
>>> s['price']
490.10
>>>
```

Щоб додати або змінити значення, використовуйте назви ключів.
```python
>>> s['shares'] = 75
>>> s['date'] = '6/6/2007'
>>>
```

Щоб видалити значення, використовуйте оператор `del`.
```python
>>> del s['date']
>>>
```

### Чому словники?

Словники корисні, коли є *багато* різних значень, і ці значення можуть бути змінені. Словники роблять ваш код більш читабельним.
```python
s['price']
# vs
s[2]
```

## Вправи

Під час кількох останніх вправ ви написали програму, яка зчитує файл даних `Data/portfolio.csv`. Використовуючи модуль `csv`, читати файл рядок за рядком доволі легко.
```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> next(rows)
['name', 'shares', 'price']
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>>
```

Хоча читати файл легко, часто з даними потрібно робити більше, ніж просто читати їх. Наприклад, можливо, ви хочете зберегти його та почати виконувати деякі обчислення. На жаль, необробленого "ряду" даних недостатньо для роботи. Наприклад, навіть простий математичний розрахунок не працює:
```python
>>> row = ['AA', '100', '32.20']
>>> cost = row[1] * row[2]
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: can't multiply sequence by non-int of type 'str'
>>>
```

Для більшого, ви зазвичай хочете якимось чином інтерпретувати вихідні дані та перетворити їх на більш корисний об’єкт, щоб ви могли працювати з ними пізніше. Два простих варіанти - це тапли або словники.

### Вправа 2.1: Тапли

У інтерактивному терміналі створіть наступний тапл, який представляє наведений вище рядок, але з числовими стовпцями, перетвореними на правильні числа:
```python
>>> t = (row[0], int(row[1]), float(row[2]))
>>> t
('AA', 100, 32.2)
>>>
```

Використовуючи це, тепер ви можете обчислити загальну вартість, помноживши акції та ціну:
```python
>>> cost = t[1] * t[2]
>>> cost
3220.0000000000005
>>>
```

Математика в Python зламалася? Що не так з відповіддю 3220.0000000000005?

Це артефакт того, що обладнання з плаваючою комою на вашому комп’ютері здатне точно представляти десяткові дроби лише в Base-2, а не в Base-10. Навіть для простих обчислень із десятковими знаками з основою 10 вводяться невеликі помилки. Це нормально, хоча, можливо, трохи дивно, якщо ви цього раніше не бачили.

Це трапляється у всіх мовах програмування, які використовують десяткові дроби з плаваючою комою, але це часто приховується під час друку. Наприклад:
```python
>>> print(f'{cost:0.2f}')
3220.00
>>>
```

Тапли доступні лише для читання. Перевірте це, спробувавши змінити кількість акцій на 75.
```python
>>> t[1] = 75
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>>
```

Хоча ви не можете змінити вміст таплу, ви завжди можете створити абсолютно новий тапл, який замінить старий.
```python
>>> t = (t[0], 75, t[2])
>>> t
('AA', 75, 32.2)
>>>
```

Щоразу, коли ви перепризначаєте існуючу назву змінної, як зверху, старе значення відкидається. Хоча наведене вище призначення може виглядати так, ніби ви змінюєте тапл, насправді ви створюєте новий тапл і викидаєте старий.

Тапли часто використовуються для упаковки та розпакування значень у змінні. Спробуйте наступне:
```python
>>> name, shares, price = t
>>> name
'AA'
>>> shares
75
>>> price
32.2
>>>
```

Візьміть вищезгадані змінні та запакуйте їх назад у кортеж:
```python
>>> t = (name, 2*shares, price)
>>> t
('AA', 150, 32.2)
>>>
```

### Вправа 2.2: Словники як структура даних

Альтернативою таплу є створення замість нього словника.
```python
>>> d = {
        'name' : row[0],
        'shares' : int(row[1]),
        'price'  : float(row[2])
    }
>>> d
{'name': 'AA', 'shares': 100, 'price': 32.2 }
>>>
```

Розрахуйте загальну вартість цих інвестицій:
```python
>>> cost = d['shares'] * d['price']
>>> cost
3220.0000000000005
>>>
```

Порівняйте цей приклад з тим самим обчисленням, з таплами вище. Змініть кількість акцій на 75.
```python
>>> d['shares'] = 75
>>> d
{'name': 'AA', 'shares': 75, 'price': 32.2 }
>>>
```

На відміну від таплів, словники можна вільно змінювати. Додайте деякі атрибути:
```python
>>> d['date'] = (6, 11, 2007)
>>> d['account'] = 12345
>>> d
{'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007), 'account': 12345}
>>>
```

### Вправа 2.3: Деякі додаткові дії зі словником

Якщо ви перетворите словник на список, ви отримаєте всі його ключі:
```python
>>> list(d)
['name', 'shares', 'price', 'date', 'account']
>>>
```

Аналогічно, якщо ви використовуєте оператор `for` для ітерації по словнику, ви отримаєте ключі також:
```python
>>> for k in d:
        print('k =', k)

k = name
k = shares
k = price
k = date
k = account
>>>
```

Спробуйте цей варіант, який виконує пошук одночасно:
```python
>>> for k in d:
        print(k, '=', d[k])

name = AA
shares = 75
price = 32.2
date = (6, 11, 2007)
account = 12345
>>>
```

Ви також можете отримати всі ключі за допомогою методу `keys()`:
```python
>>> keys = d.keys()
>>> keys
dict_keys(['name', 'shares', 'price', 'date', 'account'])
>>>
```

`keys()` трохи незвичайний, оскільки повертає спеціальний об'єкт `dict_keys`. Це накладення на оригінальний словник, який завжди дає вам поточні ключі, навіть якщо словник змінюється. Наприклад, спробуйте це:
```python
>>> del d['account']
>>> keys
dict_keys(['name', 'shares', 'price', 'date'])
>>>
```

Уважно зверніть увагу, що `'account'` зник із `keys`, навіть якщо ви не викликали `d.keys()` знову.

Більш елегантним способом спільної роботи з ключами та значеннями є використання методу `items()`. Це дає вам тапли `(ключ, значення)`:
```python
>>> items = d.items()
>>> items
dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))])
>>> for k, v in d.items():
        print(k, '=', v)

name = AA
shares = 75
price = 32.2
date = (6, 11, 2007)
>>>
```

Якщо у вас є тапли, такі як `items`, ви можете створити словник за допомогою функції `dict()`. Спробуйте наступне:
```python
>>> items
dict_items([('name', 'AA'), ('shares', 75), ('price', 32.2), ('date', (6, 11, 2007))])
>>> d = dict(items)
>>> d
{'name': 'AA', 'shares': 75, 'price':32.2, 'date': (6, 11, 2007)}
>>>
```

[Зміст](../Contents.md) \| [Попередній розділ (1.7. Функції)](../01_Introduction/07_Functions.md) \| [Наступний розділ (2.2. Контейнери)](../02_Containers.md)
