[Зміст](../Contents.md) \| [Попередній розділ (5.1. Перегляд словників)](01_Dicts_revisited.md) \| [Наступна частина (6. Генератори)](../06_Generators/00_Overview.md)

# 5.2 Класи та інкапсуляція

Під час написання класів зазвичай намагаються інкапсулювати внутрішні деталі. У цьому розділі представлено кілька ідіом програмування Python для цього, включаючи приватні змінні та властивості.

### Публічний проти приватного.

Однією з основних ролей класу є інкапсуляція даних і деталей внутрішньої реалізації об’єкта. Однак клас також визначає *публічний* інтерфейс, який зовнішній світ має використовувати для маніпулювання об’єктом. Ця різниця між деталями реалізації та публічним інтерфейсом є важливою.

### Проблема

У Python майже все про класи та об’єкти є *відкритим*.

* Ви можете легко перевірити внутрішні елементи об'єкта.
* Ви можете змінювати речі за бажанням.
* Немає сильного поняття контролю доступу (тобто членів приватного класу)

Це стає проблемою, коли ви намагаєтеся виокремити деталі *внутрішньої реалізації*.

### Інкапсуляція Python

Python покладається на конвенції програмування, щоб вказати передбачуване використання чогось. Ці умовності базуються на іменуванні. Існує загальне уявлення щодо того, що програміст повинен дотримуватись правил, а не мати мову, яка його заставляє їх дотримуватися.

### Приватні атрибути

Будь-яке ім’я атрибута з `_` на початку вважається *приватним*.

```python
class Person(object):
    def __init__(self, name):
        self._name = 0
```

Як згадувалося раніше, це лише стиль програмування. Ви все ще можете отримати до нього доступ і змінити його.

```python
>>> p = Person('Guido')
>>> p._name
'Guido'
>>> p._name = 'Dave'
>>>
```

За загальним правилом будь-яке ім’я з `_` на початку вважається внутрішньою реалізацією, незалежно від того, чи це ім’я змінної, функції чи модуля. Якщо ви використовуєте такі імена безпосередньо, ви, ймовірно, робите щось не так. Шукайте функціональність вищого рівня.

### Прості атрибути

Розглянемо наступний клас.

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
```

Цікавою особливістю є те, що ви можете встановити будь-яке значення для атрибута:

```python
>>> s = Stock('IBM', 50, 91.1)
>>> s.shares = 100
>>> s.shares = "hundred"
>>> s.shares = [1, 0, 0]
>>>
```

Ви можете подивитися на це і подумати, що вам потрібні додаткові перевірки.

```python
s.shares = '50'     # TypeError, це текст
```

Як би ви це зробили?

### Керовані атрибути

Один підхід: запровадити методи доступу.

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
	    self.set_shares(shares)
	    self.price = price

    # Функція, яка додає операцію "get".
    def get_shares(self):
        return self._shares

    # Функція, яка додає операцію "set".
    def set_shares(self, value):
        if not isinstance(value, int):
            raise TypeError('Expected an int')
        self._shares = value
```

Шкода, що це порушує весь наш існуючий код. `s.shares = 50` стає `s.set_shares(50)`

### Властивості

Існує альтернативний підхід до попереднього шаблону.

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    @property
    def shares(self):
        return self._shares

    @shares.setter
    def shares(self, value):
        if not isinstance(value, int):
            raise TypeError('Очікували int')
        self._shares = value
```

Звичайний доступ до атрибутів тепер запускає методи getter і setter у `@property` та `@shares.setter`.

```python
>>> s = Stock('IBM', 50, 91.1)
>>> s.shares         # Запускає @property
50
>>> s.shares = 75    # Запускає @shares.setter
>>>
```

За допомогою цього шаблону *не потрібно змінювати* вихідний код. Новий *setter* також викликається, коли є призначення в межах класу, зокрема всередині методу `__init__()`.

```python
class Stock:
    def __init__(self, name, shares, price):
        ...
        # Це призначення викликає сеттер нижче
        self.shares = shares
        ...

    ...
    @shares.setter
    def shares(self, value):
        if not isinstance(value, int):
            raise TypeError('Очікували int')
        self._shares = value
```

Часто виникає плутанина між властивістю та використанням приватних імен. Хоча властивість внутрішньо використовує приватну назву, як-от `_shares`, решта класу (не властивість) може продовжувати використовувати назву, як-от `shares`.

Властивості також корисні для обчислюваних атрибутів даних.

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    @property
    def cost(self):
        return self.shares * self.price
    ...
```

Це дозволяє вам відкинути зайві дужки, приховуючи той факт, що це насправді метод:

```python
>>> s = Stock('GOOG', 100, 490.1)
>>> s.shares # Змінна екземпляра
100
>>> s.cost   # Обчислене значення
49010.0
>>>
```

### Рівномірний доступ

Останній приклад показує, як надати більш однорідний інтерфейс об’єкту. Якщо ви цього не зробите, використання об’єкта може бути незрозумілим:

```python
>>> s = Stock('GOOG', 100, 490.1)
>>> a = s.cost() # Метод
49010.0
>>> b = s.shares # Атрибут даних
100
>>>
```

Чому `()` потрібні для вартості, але не для акцій? Властивість може це виправити.

### Синтаксис декоратора

Синтаксис `@` відомий як "декорація". Він визначає модифікатор
який застосовано до визначення функції, що йде відразу за ним.

```python
...
@property
def cost(self):
    return self.shares * self.price
```

Більш детальна інформація наведена в [Розділі 7](../07_Advanced_Topics/00_Overview).

### Атрибут `__slots__`

Ви можете обмежити набір імен атрибутів.

```python
class Stock:
    __slots__ = ('name','_shares','price')
    def __init__(self, name, shares, price):
        self.name = name
        ...
```

Це викличе помилку для інших атрибутів.

```python
>>> s.price = 385.15
>>> s.prices = 410.2
Traceback (most recent call last):
File "<stdin>", line 1, in ?
AttributeError: 'Stock' object has no attribute 'prices'
```

Хоча це запобігає помилкам і обмежує використання об’єктів, насправді це використовується для підвищення продуктивності та дозволяє Python використовувати пам’ять ефективніше.

### Остаточні коментарі щодо інкапсуляції

Не перестарайтеся з приватними атрибутами, властивостями, слотами тощо. Вони служать певній меті, і ви можете побачити їх під час читання іншого коду Python. Однак вони не потрібні для більшості повсякденного кодування.

## Вправи

### Вправа 5.6: Прості властивості

Властивості є корисним способом додавання «обчислених атрибутів» до об’єкта. У `stock.py` ви створили об’єкт `Stock`. Зверніть увагу, що на вашому об’єкті є невелика невідповідність у тому, як витягуються різні типи даних:

```python
>>> from stock import Stock
>>> s = Stock('GOOG', 100, 490.1)
>>> s.shares
100
>>> s.price
490.1
>>> s.cost()
49010.0
>>>
```

Зокрема, зверніть увагу, як вам потрібно додати додаткові `()` до `cost`, оскільки це метод.

Ви можете позбутися додаткових `()` у `cost()`, якщо перетворите його на властивість. Візьміть свій клас `Stock` і змініть його так, щоб розрахунок вартості працював так:

```python
>>> ================================ RESTART ================================
>>> from stock import Stock
>>> s = Stock('GOOG', 100, 490.1)
>>> s.cost
49010.0
>>>
```

Спробуйте викликати `s.cost()` як функцію та помітьте, що вона не працює тепер, коли `cost` визначено як властивість.

```python
>>> s.cost()
... помилка ...
>>>
```

Внесення цієї зміни, ймовірно, порушить вашу попередню програму `pcost.py`. Можливо, вам доведеться повернутися назад і позбутися `()` у методі `cost()`.

### Вправа 5.7: Властивості та параметри

Змініть атрибут `shares` так, щоб значення зберігалося в приватному атрибуті та щоб використовувалася пара функцій властивостей, щоб гарантувати, що воно завжди має ціле значення. Ось приклад очікуваної поведінки:

```python
>>> ================================ RESTART ================================
>>> from stock import Stock
>>> s = Stock('GOOG',100,490.10)
>>> s.shares = 50
>>> s.shares = 'a lot'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: очікувалось ціле число
>>>
```

### Вправа 5.8: Додавання слотів

Змініть клас `Stock`, щоб він мав атрибут `__slots__`. Потім переконайтеся, що нові атрибути не можна додати:

```python
>>> ================================ RESTART ================================
>>> from stock import Stock
>>> s = Stock('GOOG', 100, 490.10)
>>> s.name
'GOOG'
>>> s.blah = 42
... дивіться, що відбувається ...
>>>
```

Коли ви використовуєте `__slots__`, Python використовує більш ефективне внутрішнє представлення об’єктів. Що станеться, якщо ви спробуєте перевірити базовий словник `s` вище?

```python
>>> s.__dict__
... дивіться, що відбувається ...
>>>
```

Слід зазначити, що `__slots__` найчастіше використовується для оптимізації класів, які служать структурами даних. Використання слотів змусить такі програми використовувати набагато менше пам’яті та працювати дещо швидше. Однак вам слід уникати `__slots__` у більшості інших класів.

[Зміст](../Contents.md) \| [Попередній розділ (5.1. Перегляд словників)](01_Dicts_revisited.md) \| [Наступна частина (6. Генератори)](../06_Generators/00_Overview.md)