[Зміст](../Contents.md) \| [Попередній розділ (4.4. Визначення винятків)](../04_Classes_objects/04_Defining_exceptions.md) \| [Наступний розділ (5.2 Методи інкапсуляції)](02_Classes_encapsulation.md)

# 5.1 Перегляд словників

Об'єктна система Python значною мірою базується на реалізації із використанням словників. У цьому розділі це обговоримо.

### Словники, переглянуто

Пам’ятайте, що словник – це набір іменованих значень.

```python
stock = {
    'name' : 'GOOG',
    'shares' : 100,
    'price' : 490.1
}
```

Словники зазвичай використовуються для простих структур даних. Однак вони використовуються для критичних частин інтерпретатора і цілком можуть бути *найважливішим типом даних у Python*.

### Словники і модулі

У межах модуля словник містить усі глобальні змінні та функції.

```python
# foo.py

x = 42
def bar():
    ...

def spam():
    ...
```

Якщо ви перевірите `foo.__dict__` або `globals()`, ви побачите словник.

```python
{
    'x' : 42,
    'bar' : <функція bar>,
    'spam' : <функція spam>
}
```

### Словники та об'єкти

Визначені користувачем об’єкти також використовують словники як для даних екземплярів, так і для класів. Насправді вся система об’єктів — це здебільшого додатковий рівень, який розміщується поверх словників.

Словник містить дані екземпляра, `__dict__`.

```python
>>> s = Stock('GOOG', 100, 490.1)
>>> s.__dict__
{'name' : 'GOOG', 'shares' : 100, 'price': 490.1 }
```

Ви заповнюєте цей словник (і екземпляр) під час призначення значень для `self`.

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
```

Дані екземпляра, `self.__dict__`, виглядають так:

```python
{
    'name': 'GOOG',
    'shares': 100,
    'price': 490.1
}
```

**Кожен екземпляр отримує власний приватний словник.**

```python
s = Stock('GOOG', 100, 490.1)     # {'name' : 'GOOG','shares' : 100, 'price': 490.1 }
t = Stock('AAPL', 50, 123.45)     # {'name' : 'AAPL','shares' : 50, 'price': 123.45 }
```

Якщо ви створили 100 екземплярів якогось класу, там буде 100 словників, які зберігають дані.

### Члени класу

Окремий словник містить і методи.

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    def cost(self):
        return self.shares * self.price

    def sell(self, nshares):
        self.shares -= nshares
```

Словник знаходиться в `Stock.__dict__`.

```python
{
    'cost': <function>,
    'sell': <function>,
    '__init__': <function>
}
```

### Примірники та класи

Примірники та класи пов’язані між собою. Атрибут `__class__` посилається на клас.

```python
>>> s = Stock('GOOG', 100, 490.1)
>>> s.__dict__
{ 'name': 'GOOG', 'shares': 100, 'price': 490.1 }
>>> s.__class__
<class '__main__.Stock'>
>>>
```

Словник екземплярів містить дані, унікальні для кожного екземпляра, тоді як словник класу містить дані, якими спільно користуються *всі* екземпляри.

### Доступ до атрибутів

Коли ви працюєте з об’єктами, ви отримуєте доступ до даних і методів за допомогою оператора `.` (точка).

```python
x = obj.name          # Отримання даних
obj.name = value      # Призначення
del obj.name          # Видалення
```

Ці операції безпосередньо пов’язані зі словниками, які знаходяться під обкладинками.

### Зміна екземплярів

Операції, які змінюють об’єкт, оновлюють словник, що лежить в основі.

```python
>>> s = Stock('GOOG', 100, 490.1)
>>> s.__dict__
{ 'name':'GOOG', 'shares': 100, 'price': 490.1 }
>>> s.shares = 50       # Призначення
>>> s.date = '6/7/2007' # Призначення
>>> s.__dict__
{ 'name': 'GOOG', 'shares': 50, 'price': 490.1, 'date': '6/7/2007' }
>>> del s.shares        # Видалення
>>> s.__dict__
{ 'name': 'GOOG', 'price': 490.1, 'date': '6/7/2007' }
>>>
```

### Читання атрибутів

Припустімо, ви зчитуєте атрибут екземпляра.

```python
x = obj.name
```

Атрибут може існувати в двох місцях:

* Локальний словник екземплярів.
* Словник класу.

Необхідно перевірити обидва словники. Спочатку перевірте локальний `__dict__`. Якщо не знайдено, перегляньте `__dict__` класу через `__class__`.

```python
>>> s = Stock(...)
>>> s.name
'GOOG'
>>> s.cost()
49010.0
>>>
```

Ця схема пошуку полягає в тому, як члени *класу* отримують спільний доступ для всіх екземплярів.

### Як працює успадкування

Класи можуть успадковуватись від інших класів.

```python
class A(B, C):
    ...
```

Базові класи зберігаються в таплі в кожному класі.

```python
>>> A.__bases__
(<class '__main__.B'>, <class '__main__.C'>)
>>>
```

Це забезпечує посилання на батьківські класи.

### Читання атрибутів із успадкуванням

Логічно процес пошуку атрибута виглядає наступним чином. Спочатку перевірте локальний `__dict__`. Якщо не знайдено, подивіться в `__dict__` класу. Якщо не знайдено в класі, перегляньте базові класи через `__bases__`. Однак є деякі тонкі аспекти цього, які обговорюватимуться далі.

### Читання атрибутів з єдиним успадкуванням

В ієрархіях успадкування атрибути можна знайти шляхом переходу по дереву успадкування по порядку.

```python
class A: pass
class B(A): pass
class C(A): pass
class D(B): pass
class E(D): pass
```
З єдиним успадкуванням є єдиний шлях до вершини. Ви зупиняєтеся на першому співпадінні.

### Порядок вирішення методів або MRO

Python попередньо обчислює ланцюжок успадкування та зберігає його в атрибуті *MRO* класу. Ви можете переглянути його.

```python
>>> E.__mro__
(<class '__main__.E'>, <class '__main__.D'>,
 <class '__main__.B'>, <class '__main__.A'>,
 <type 'object'>)
>>>
```

Цей ланцюжок називається **Порядком вирішення методу**. Щоб знайти атрибут, Python проходить MRO по порядку. Перше співпадіння виграє.

### MRO у множинному успадкуванні

При множинному успадкуванні єдиного шляху до вершини немає. Давайте розглянемо приклад.

```python
class A: pass
class B: pass
class C(A, B): pass
class D(B): pass
class E(C, D): pass
```

Що відбувається, коли ви отримуєте доступ до атрибута?

```python
e = E()
e.attr
```

Виконується процес пошуку атрибутів, але в якому порядку? Це проблема.

Python використовує *кооперативне множинне успадкування*, яке підпорядковується деяким правилам упорядкування класів.

* Дітей завжди перевіряють перед батьками
* Батьки (якщо їх декілька) завжди перевіряються в зазначеному порядку.

MRO обчислюється шляхом сортування всіх класів в ієрархії відповідно до цих правил.

```python
>>> E.__mro__
(
  <class 'E'>,
  <class 'C'>,
  <class 'A'>,
  <class 'D'>,
  <class 'B'>,
  <class 'object'>)
>>>
```

Базовий алгоритм називається «алгоритм лінеаризації C3». Точні деталі не важливі, доки ви пам’ятаєте, що ієрархія класів підпорядковується тим самим правилам порядку, яких ви могли б дотримуватися, якщо б ваш будинок горів і вам довелося евакуюватися — спочатку діти, а потім батьки.

### Повторне використання дивного коду (включає множинне успадкування)

Розглянемо два абсолютно не пов'язані об'єкти:

```python
class Dog:
    def noise(self):
        return 'Bark'

    def chase(self):
        return 'Chasing!'

class LoudDog(Dog):
    def noise(self):
        # Спільність коду з LoudBike (внизу)
        return super().noise().upper()
```

І

```python
class Bike:
    def noise(self):
        return 'On Your Left'

    def pedal(self):
        return 'Pedaling!'

class LoudBike(Bike):
    def noise(self):
        # Спільність коду з LoudDog (вгорі)
        return super().noise().upper()
```

У реалізації `LoudDog.noise()` і `LoudBike.noise()` існує спільність коду. Насправді код точно такий же. Звичайно, такий код обов’язково привабить інженерів програмного забезпечення.

### Патерн "Mixin".

Шаблон *Mixin* — це клас із фрагментом коду.

```python
class Loud:
    def noise(self):
        return super().noise().upper()
```

Цей клас не можна використовувати окремо. Він змішується з іншими класами через успадкування.

```python
class LoudDog(Loud, Dog):
    pass

class LoudBike(Loud, Bike):
    pass
```

На диво, гучність тепер реалізована лише один раз і повторно використана у двох абсолютно не пов’язаних класах. Такий трюк є одним із основних застосувань множинного успадкування в Python.

### Чому `super()`

Завжди використовуйте `super()`, коли переписуєте методи.

```python
class Loud:
    def noise(self):
        return super().noise().upper()
```

`super()` передає *наступний клас* на MRO.

Складність полягає в тому, що ви не знаєте, який саме. Особливо ви не знаєте, що там далі, якщо використовується множинне успадкування.

### Деякі застереження

Множинне успадкування є потужним інструментом. Пам’ятайте, що з владою приходить відповідальність. Фреймворки/бібліотеки іноді використовують його для розширених функцій, пов’язаних із композицією компонентів. Тепер забудьте, що ви це бачили.

## Вправи

У Розділі 4 ви визначили клас `Stock`, який представляє пакет акцій. У цій вправі ми будемо використовувати цей клас. Перезапустіть інтерпретатор і зробіть кілька екземплярів:

```python
>>> ================================ RESTART ================================
>>> from stock import Stock
>>> goog = Stock('GOOG',100,490.10)
>>> ibm  = Stock('IBM',50, 91.23)
>>>
```

### Вправа 5.1: Представлення екземплярів

В інтерактивній оболонці перевірте базові словники двох створених екземплярів:

```python
>>> goog.__dict__
... перегляньте вивід ...
>>> ibm.__dict__
... перегляньте вивід ...
>>>
```

### Вправа 5.2: Модифікація даних екземпляра

Спробуйте встановити новий атрибут для одного з наведених вище випадків:

```python
>>> goog.date = '6/11/2007'
>>> goog.__dict__
... перегляньте вивід ...
>>> ibm.__dict__
... перегляньте вивід ...
>>>
```

У наведеному вище виводі ви помітите, що примірник `goog` має атрибут `date`, тоді як примірник `ibm` його не має. Важливо зазначити, що Python насправді не накладає жодних обмежень на атрибути. Наприклад, атрибути екземпляра не обмежуються тими, що встановлені в методі `__init__()`.

Замість встановлення атрибута спробуйте розмістити нове значення безпосередньо в об’єкті `__dict__`:

```python
>>> goog.__dict__['time'] = '9:45am'
>>> goog.time
'9:45am'
>>>
```

Тут ви справді помічаєте той факт, що екземпляр — це лише шар поверх словника. Примітка: слід підкреслити, що пряме маніпулювання словником є рідкістю - ви завжди повинні писати свій код із використанням синтаксису (.).

### Вправа 5.3: Роль класів

Визначення, які складають визначення класу, спільні для всіх екземплярів цього класу. Зауважте, що всі екземпляри мають зворотне посилання на відповідний клас:

```python
>>> goog.__class__
... перегляньте вивід ...
>>> ibm.__class__
... перегляньте вивід ...
>>>
```

Спробуйте викликати метод для екземплярів:

```python
>>> goog.cost()
49010.0
>>> ibm.cost()
4561.5
>>>
```

Зауважте, що назва 'cost' не визначена ні в `goog.__dict__`, ні в `ibm.__dict__`. Замість цього він надається словником класу. Спробуйте це:

```python
>>> Stock.__dict__['cost']
... перегляньте вивід ...
>>>
```

Спробуйте викликати метод `cost()` безпосередньо через словник:

```python
>>> Stock.__dict__['cost'](goog)
49010.0
>>> Stock.__dict__['cost'](ibm)
4561.5
>>>
```

Зверніть увагу на те, як ви викликаєте функцію, визначену у визначенні класу, і як аргумент `self` отримує екземпляр.

Спробуйте додати новий атрибут до класу `Stock`:

```python
>>> Stock.foo = 42
>>>
```

Зверніть увагу, як цей новий атрибут тепер відображається в усіх екземплярах:

```python
>>> goog.foo
42
>>> ibm.foo
42
>>>
```

Однак зауважте, що це не є частиною словника екземплярів:

```python
>>> goog.__dict__
... подивіться на вихід і помітите, що немає атрибута "foo". ...
>>>
```

Причина, по якій ви можете отримати доступ до атрибута `foo` в екземплярах, полягає в тому, що Python завжди перевіряє словник класу, якщо він не може знайти щось у самому екземплярі.

Примітка. Ця частина вправи ілюструє те, що називається змінною класу. Припустімо, наприклад, що у вас є такий клас:

```python
class Foo(object):
     a = 13                  # Змінна класу
     def __init__(self,b):
         self.b = b          # Змінна екземпляра
```

У цьому класі змінна `a`, призначена в тілі самого класу, є "змінною класу". Його спільно використовують усі створені екземпляри. Наприклад:
```python
>>> f = Foo(10)
>>> g = Foo(20)
>>> f.a          # Перевірте змінну класу (однакова для обох екземплярів)
13
>>> g.a
13
>>> f.b          # Перегляньте змінну екземпляра (різняться)
10
>>> g.b
20
>>> Foo.a = 42   # Змініть значення змінної класу
>>> f.a
42
>>> g.a
42
>>>
```

### Вправа 5.4: Зв'язані методи

Тонкою особливістю Python є те, що виклик методу насправді включає два кроки та щось, відоме як прив’язаний метод. Наприклад:

```python
>>> s = goog.sell
>>> s
<bound method Stock.sell of Stock('GOOG', 100, 490.1)>
>>> s(25)
>>> goog.shares
75
>>>
```

Зв’язані методи фактично містять усі елементи, необхідні для виклику методу. Наприклад, вони зберігають записи функції, що реалізує метод:

```python
>>> s.__func__
<function sell at 0x10049af50>
>>>
```

Це те саме значення, яке міститься в словнику `Stock`.

```python
>>> Stock.__dict__['sell']
<function sell at 0x10049af50>
>>>
```

Зв’язані методи також записують екземпляр, який є аргументом `self`.

```python
>>> s.__self__
Stock('GOOG',75,490.1)
>>>
```

Коли ви викликаєте функцію за допомогою `()`, усі частини збираються разом. Наприклад, виклик `s(25)` насправді робить це:

```python
>>> s.__func__(s.__self__, 25)    # Такий же, як s(25)
>>> goog.shares
50
>>>
```

### Вправа 5.5: Спадкування

Створіть новий клас, який успадковує `Stock`.

```
>>> class NewStock(Stock):
        def yow(self):
            print('Yow!')

>>> n = NewStock('ACME', 50, 123.45)
>>> n.cost()
6172.50
>>> n.yow()
Yow!
>>>
```

Спадкування реалізовано шляхом розширення процесу пошуку атрибутів. Атрибут `__bases__` має тапл безпосередніх батьків:

```python
>>> NewStock.__bases__
(<class 'stock.Stock'>,)
>>>
```

Атрибут `__mro__` містить кортеж із усіма батьками в тому порядку, у якому вони шукатимуть атрибути.

```python
>>> NewStock.__mro__
(<class '__main__.NewStock'>, <class 'stock.Stock'>, <class 'object'>)
>>>
```

Ось як можна знайти метод `cost()` екземпляра `n` вище:

```python
>>> for cls in n.__class__.__mro__:
        if 'cost' in cls.__dict__:
            break

>>> cls
<class '__main__.Stock'>
>>> cls.__dict__['cost']
<function cost at 0x101aed598>
>>>
```

[Зміст](../Contents.md) \| [Попередній розділ (4.4. Визначення винятків)](../04_Classes_objects/04_Defining_exceptions.md) \| [Наступний розділ (5.2 Методи інкапсуляції)](02_Classes_encapsulation.md)