[Зміст](../Contents.md) \| [Попередній розділ (1.6. Файли)](06_Files.md) \| [Наступний розділ (2.0. Робота з даними)](../02_Working_with_data/00_Overview.md)

# 1.7 Функції

Коли ваші програми починають розширюватися, вам захочеться організувати їх. Цей розділ коротко представляє функції та бібліотечні модулі. Також додамо вступ до обробки помилок і роботи з винятками.

### Користувацькі функції
Використовуйте функції для коду, який потрібно використовувати повторно. Ось так виглядає функція:
```python
def sumcount(n):
    '''
    Повертає суму перших n цілих чисел
    '''
    total = 0
    while n > 0:
        total += n
        n -= 1
    return total
```

Щоб викликати функцію:
```python
a = sumcount(100)
```

Функція — це ряд операторів, які виконують деяке завдання і повертають результат. Ключове слово `return` потрібне для явного визначення значення, що повертається функцією.

### Функції з бібліотек

Python поставляється з великою стандартною бібліотекою. Доступ до модулів бібліотеки здійснюється за допомогою `import`. Наприклад:
```python
import math
x = math.sqrt(10)

import urllib.request
u = urllib.request.urlopen('http://www.python.org/')
data = u.read()
```

Ми розглянемо бібліотеки та модулі більш детально пізніше.

### Помилки та винятки

Функції повідомляють про помилки як винятки. Виняток спричиняє припинення функції й може
призведе до зупинки всієї програми, якщо її не обробляти.

Спробуйте це у своєму REPL для Python.
```python
>>> int('N/A')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: 'N/A'
>>>
```
З метою полегшення пошуку та виправлення помилок, повідомлення описує, що сталося, де сталася помилка, і зворотне відстеження, що показує інші виклики функцій, які призвели до збою.

### Перехоплення та обробка винятків
Винятки можна ідентифікувати (ловити/catch) та обробляти. Щоб спіймати, використовуйте оператор `try - except`.
```python
for line in f:
    fields = line.split()
    try:
        shares = int(fields[1])
    except ValueError:
        print("Не можу прочитати", line)
    ...
```
Ім’я `ValueError` має відповідати типу помилки, яку ви намагаєтеся зловити.

Часто важко точно визначити, які види помилок можуть виникнути заздалегідь залежно від операції, що виконується. На краще або
на гірше, обробка винятків часто додається *після* того як програма несподівано аварійно завершила роботу (типу "блін, ми забули про цю помилку. Треба це виправити!").

### Створення винятків

Щоб викликати виняток, використовуйте оператор `raise`.
```python
raise RuntimeError('Що за фігня')
```

Це призведе до припинення програми з винятковим відстеженням. Якщо не перехоплено блоком `try-except`.
```bash
% python3 foo.py
Traceback (most recent call last):
  File "foo.py", line 21, in <module>
    raise RuntimeError("Що за фігня")
RuntimeError: Що за фігня
```

## Вправи

### Вправа 1.29: Визначення функції

Спробуйте написати просту функцію:
```python
>>> def greeting(name):
        'Друкує привітання'
        print('Привіт', name)

>>> greeting('Діма')
Привіт Діма
>>> greeting('Ната')
Привіт Ната
>>>
```
Якщо першим оператором функції є рядок, він служить документацією.
Спробуйте ввести команду, наприклад `help(greeting)`, щоб побачити її відображення.

### Вправа 1.30: Перетворення скрипту у функцію

Візьміть код, який ви написали для програми `pcost.py` у [Вправі 1.27](06_Files.md) і перетворити його на функцію `portfolio_cost(filename)`. Ця функція приймає ім'я файлу як вхідну інформацію, зчитує дані портфоліо в цьому файлі, і повертає загальну вартість портфеля у вигляді плаваючого значення.

Щоб використовувати свою функцію, змініть програму, щоб вона виглядала якось так:
```python
def portfolio_cost(filename):
    ...
    # Ваш код тут
    ...

cost = portfolio_cost('Data/portfolio.csv')
print('Total cost:', cost)
```

Коли ви запускаєте свою програму, ви повинні побачити той самий результат, що й раніше. Після запуску програми ви також можете викликати свою функцію
інтерактивно, ввівши наступне:
```bash
bash $ python3 -i pcost.py
```

Це дозволить вам викликати свою функцію з інтерактивного режиму.
```python
>>> portfolio_cost('Data/portfolio.csv')
44671.15
>>>
```

Можливість інтерактивно експериментувати зі своїм кодом корисна для тестування та коригування програм.

### Вправа 1.31: Обробка помилок

Що станеться, якщо ви спробуєте виконати свою функцію у файлі з деякими відсутніми полями?
```python
>>> portfolio_cost('Data/missing.csv')
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "pcost.py", line 11, in portfolio_cost
    nshares    = int(fields[1])
ValueError: invalid literal for int() with base 10: ''
>>>
```

На цьому етапі ви стоїте перед рішенням. Щоб програма працювала ви можете або очистити вихідний вхідний файл, усунувши неправильні рядки, або ви можете змінити свій код, щоб обробляти неправильні дані якимсь чином.

Змініть програму `pcost.py`, щоб зловити виняток, надрукуйте попередження та продовжіть обробку решти файлу.

### Вправа 1.32: Використання функції бібліотеки

Python поставляється з великою стандартною бібліотекою корисних функцій. Одна бібліотека, яка тут може бути корисною, - це модуль `csv`. Ви повинні використовувати її завжди, коли вам доводиться працювати з файлами даних CSV. Ось приклад як це працює:
```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> headers
['name', 'shares', 'price']
>>> for row in rows:
        print(row)

['AA', '100', '32.20']
['IBM', '50', '91.10']
['CAT', '150', '83.44']
['MSFT', '200', '51.23']
['GE', '95', '40.37']
['MSFT', '50', '65.10']
['IBM', '100', '70.44']
>>> f.close()
>>>
```

Одна приємна річ у модулі `csv` полягає в тому, що він має справу з різноманітністю деталей низького рівня, такі як цитування та правильне розділення комами. В наведеному вище прикладі ви помітите, що він видалив подвійні лапки від імен у першому стовпці.

Змініть програму `pcost.py` так, щоб вона використовувала модуль `csv` для обробки даних та спробуйте запустити попередні приклади.

### Вправа 1.33: Читання з командного рядка

У програмі `pcost.py` ім'я вхідного файлу було закріплено в коді:
```python
# pcost.py

def portfolio_cost(filename):
    ...
    # Ваш код тут
    ...

cost = portfolio_cost('Data/portfolio.csv')
print('Total cost:', cost)
```

Це нормально для навчання та тестування, але в реальній програмі ви мабуть, не зробили б такого.

Замість цього ви можете передати ім'я файлу як аргумент до скрипту. Спробуйте змінити нижню частину програми наступним чином:
```python
# pcost.py
import sys

def portfolio_cost(filename):
    ...
    # Ваш код тут
    ...

if len(sys.argv) == 2:
    filename = sys.argv[1]
else:
    filename = 'Data/portfolio.csv'

cost = portfolio_cost(filename)
print('Total cost:', cost)
```
`sys.argv` – це список, який містить аргументи, передані в командному рядку (якщо такі є).

Щоб запустити вашу програму, вам потрібно запустити Python-файл з терміналу.

Наприклад, з bash на Unix:
```bash
bash % python3 pcost.py Data/portfolio.csv
Total cost: 44671.15
bash %
```

[Зміст](../Contents.md) \| [Попередній розділ (1.6. Файли)](06_Files.md) \| [Наступний розділ (2.0. Робота з даними)](../02_Working_with_data/00_Overview.md)
