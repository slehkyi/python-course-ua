[Зміст](../Contents.md) \| [Попередній розділ (3.6. Обговорення дизайну)](../03_Program_organization/06_Design_discussion.md) \| [Наступний розділ (4.2. Успадкування)](02_Inheritance.md)

# 4.1 Класи

У цьому розділі представлено оператор класу та ідею створення нових об’єктів.

### Об'єктно-орієнтоване (ОО) програмування

Техніка програмування, де код організований як набір *об'єктів*.

*Об’єкт* складається з:

* Дані. Атрибути
* Поведінка. Методи, які є функціями, застосованими до об’єкта.

Під час цього курсу ви вже використовували деяку частину ООП.

Наприклад, маніпулювання списком.

```python
>>> nums = [1, 2, 3]
>>> nums.append(4)      # Метод
>>> nums.insert(1,10)   # Метод
>>> nums
[1, 10, 2, 3, 4]        # Дані
>>>
```

`nums` - це *екземпляр* списку.

Методи (`append()` і `insert()`) додаються до екземпляра (`nums`).

### Оператор `class`

Використовуйте оператор `class`, щоб визначити новий об'єкт.

```python
class Player:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.health = 100

    def move(self, dx, dy):
        self.x += dx
        self.y += dy

    def damage(self, pts):
        self.health -= pts
```

У двох словах, клас — це набір функцій, які виконують різні операції над так званими *інстранціями*.

### Інстанції

Інстанції — це фактичні *об’єкти*, якими ви керуєте у своїй програмі.

Вони створюються шляхом виклику класу як функції.

```python
>>> a = Player(2, 3)
>>> b = Player(10, 20)
>>>
```

`a` і `b` є екземплярами (інстанціями) `Player`.

*Підкреслюємо: оператор класу - це лише визначення (він сам по собі нічого не робить). Подібно до визначення функції.*

### Дані екземпляра (інстанції)

Кожен екземпляр має власні локальні дані.
```python
>>> a.x
2
>>> b.x
10
```

Ці дані ініціалізуються використовуючи `__init__()`.

```python
class Player:
    def __init__(self, x, y):
        # Будь-яке значення, збережене в `self`, є даними екземпляра
        self.x = x
        self.y = y
        self.health = 100
```

Немає обмежень на загальну кількість або тип збережених атрибутів.

### Методи екземплярів

Методи екземплярів — це функції, які застосовуються до екземплярів об’єкта.

```python
class Player:
    ...
    # `move` є методом
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
```

Сам об'єкт завжди передається як перший аргумент.

```python
>>> a.move(1, 2)

# `a` відповідає `self`
# `1` відповідає `dx`
# `2` відповідає `dy`
def move(self, dx, dy):
```

За домовленістю екземпляр називається `self`. Однак фактична використана назва не має значення. Об’єкт завжди передається як перший аргумент. Це просто стиль програмування Python, щоб назвати цей аргумент `self`.

### Огляд класу

Класи не визначають область імен.

```python
class Player:
    ...
    def move(self, dx, dy):
        self.x += dx
        self.y += dy

    def left(self, amt):
        move(-amt, 0)       # НІТ. Викликає глобальну функцію `move`.
        self.move(-amt, 0)  # ТАК. Викликає метод `move` зверху.
```

Якщо ви хочете оперувати екземпляром, ви завжди посилаєтеся на нього явно (наприклад, `self`).

## Вправи

Починаючи з цього набору вправ, ми починаємо вносити низку змін до існуючого коду з попередніх розділів. Для початку важливо мати робочу версію вправи 3.18. Якщо у вас його немає, працюйте з кодом рішення, який можна знайти в каталозі `Solutions/3_18`. Це ОК просто його скопіювати.

### Вправа 4.1: Об’єкти як структури даних

У розділах 2 і 3 ми працювали з даними, представленими у вигляді таплів і словників. Наприклад, пакет акцій можна представити у вигляді такого таплу:

```python
s = ('GOOG',100,490.10)
```

або як такий словник:

```python
s = { 'name'   : 'GOOG',
      'shares' : 100,
      'price'  : 490.10
}
```

Ви навіть можете написати функції для маніпулювання такими даними. Наприклад:

```python
def cost(s):
    return s['shares'] * s['price']
```

Однак, коли ваша програма стає великою, ви можете створити краще відчуття організації. Таким чином, іншим підходом до представлення даних було б визначення класу. Створіть файл під назвою `stock.py` і визначте клас `Stock`, який представлятиме окремий пакет акцій. Нехай екземпляри `Stock` мають атрибути `name`, `shares` і `price`. Наприклад:

```python
>>> import stock
>>> a = stock.Stock('GOOG',100,490.10)
>>> a.name
'GOOG'
>>> a.shares
100
>>> a.price
490.1
>>>
```

Створіть ще кілька об’єктів `Stock` і пограйтеся ними. Наприклад:

```python
>>> b = stock.Stock('AAPL', 50, 122.34)
>>> c = stock.Stock('IBM', 75, 91.75)
>>> b.shares * b.price
6117.0
>>> c.shares * c.price
6881.25
>>> stocks = [a, b, c]
>>> stocks
[<stock.Stock object at 0x37d0b0>, <stock.Stock object at 0x37d110>, <stock.Stock object at 0x37d050>]
>>> for s in stocks:
     print(f'{s.name:>10s} {s.shares:>10d} {s.price:>10.2f}')

... подивіться на результат ...
>>>
```

Тут слід підкреслити, що клас `Stock` діє як фабрика для створення екземплярів об’єктів. По суті, ви викликаєте це як функцію, і вона створює для вас новий об’єкт. Крім того, слід підкреслити, що кожен об’єкт є окремим --- кожен з них має власні дані, які відокремлені від інших об’єктів, які були створені.

Об’єкт, визначений класом, чимось схожий на словник, але має дещо інший синтаксис. Наприклад, замість того, щоб писати `s['name']` або `s['price']`, тепер ви пишете `s.name` і `s.price`.

### Вправа 4.2: Додавання деяких методів

За допомогою класів ви можете додавати функції до своїх об’єктів. Вони відомі як методи та є функціями, які працюють з даними, що зберігаються всередині об’єкта. Додайте методи `cost()` і `sell()` до свого об’єкта `Stock`. Вони повинні працювати так:

```python
>>> import stock
>>> s = stock.Stock('GOOG', 100, 490.10)
>>> s.cost()
49010.0
>>> s.shares
100
>>> s.sell(25)
>>> s.shares
75
>>> s.cost()
36757.5
>>>
```

### Вправа 4.3: Створення списку екземплярів

Спробуйте виконати ці дії, щоб створити список екземплярів Stock зі списку словників. Потім обчисліть загальну вартість:

```python
>>> import fileparse
>>> with open('Data/portfolio.csv') as lines:
...     portdicts = fileparse.parse_csv(lines, select=['name','shares','price'], types=[str,int,float])
...
>>> portfolio = [ stock.Stock(d['name'], d['shares'], d['price']) for d in portdicts]
>>> portfolio
[<stock.Stock object at 0x10c9e2128>, <stock.Stock object at 0x10c9e2048>, <stock.Stock object at 0x10c9e2080>,
 <stock.Stock object at 0x10c9e25f8>, <stock.Stock object at 0x10c9e2630>, <stock.Stock object at 0x10ca6f748>,
 <stock.Stock object at 0x10ca6f7b8>]
>>> sum([s.cost() for s in portfolio])
44671.15
>>>
```

### Вправа 4.4: Використання вашого класу

Змініть функцію `read_portfolio()` у програмі `report.py` так, щоб вона зчитувала портфоліо в список екземплярів `Stock`, як щойно було показано у вправі 4.3. Зробивши це, виправте весь код у `report.py` і `pcost.py`, щоб він працював із екземплярами `Stock` замість словників.

Підказка: вам не доведеться вносити серйозні зміни в код. Здебільшого ви змінюватимете доступ до словника, наприклад `s['shares']` на `s.shares`.

Ви повинні мати можливість запускати свої функції так само, як і раніше:

```python
>>> import pcost
>>> pcost.portfolio_cost('Data/portfolio.csv')
44671.15
>>> import report
>>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
>>>
```

[Зміст](../Contents.md) \| [Попередній розділ (3.6. Обговорення дизайну)](../03_Program_organization/06_Design_discussion.md) \| [Наступний розділ (4.2. Успадкування)](02_Inheritance.md)
