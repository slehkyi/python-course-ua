[Зміст](../Contents.md) \| [Попередній розділ (4.1. Класи)](01_Class.md) \| [Наступний розділ (4.3. Спеціальні методи)](03_Special_methods.md)

# 4.2 Успадкування

Успадкування є широко використовуваним інструментом для написання розширюваних програм.
Цей розділ описує цю ідею.

### Вступ

Успадкування використовується для спеціалізації існуючих об'єктів:

```python
class Parent:
    ...

class Child(Parent):
    ...
```

Новий клас `Дитина` називається похідним класом або підкласом. `Батьківський` клас відомий як базовий клас або суперклас. `Батька` вказано в `()` після назви класу, `class Child(Parent):`.

### Розширення

З успадкуванням ви приймаєте існуючий клас і займаєтесь наступним:

* Додаванням нових методів
* Перевизначенням деяких існуючих методів
* Додаванням нових атрибутів до екземплярів

Зрештою, ви **розширюєте наявний код**.

### Приклад

Припустімо, що це ваш початковий клас:

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    def cost(self):
        return self.shares * self.price

    def sell(self, nshares):
        self.shares -= nshares
```

Ви можете змінити будь-яку його частину через успадкування.

### Додати новий метод

```python
class MyStock(Stock):
    def panic(self):
        self.sell(self.shares)
```

Приклад використання.

```python
>>> s = MyStock('GOOG', 100, 490.1)
>>> s.sell(25)
>>> s.shares
75
>>> s.panic()
>>> s.shares
0
>>>
```

### Перевизначення існуючого методу

```python
class MyStock(Stock):
    def cost(self):
        return 1.25 * self.shares * self.price
```

Приклад використання.

```python
>>> s = MyStock('GOOG', 100, 490.1)
>>> s.cost()
61262.5
>>>
```

Новий метод замінює старий. Інші методи не впливають. Це приголомшливо.

## Перевизначення

Іноді клас розширює існуючий метод, але хоче використовувати оригінальну реалізацію всередині перевизначення. Для цього використовуйте `super()`:

```python
class Stock:
    ...
    def cost(self):
        return self.shares * self.price
    ...

class MyStock(Stock):
    def cost(self):
        # Перевірте виклик методу `super`
        actual_cost = super().cost()
        return 1.25 * actual_cost
```

Використовуйте `super()`, щоб викликати попередню версію.

*Увага: у Python 2 синтаксис був більш докладним. Але до одного місця - цієї мови вже скоро ніде не буде*

```python
actual_cost = super(MyStock, self).cost()
```

### `__init__` і спадок

Якщо `__init__` перевизначено, необхідно ініціалізувати батьківський елемент.

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

class MyStock(Stock):
    def __init__(self, name, shares, price, factor):
        # Перевірте виклик `super` та `__init__`
        super().__init__(name, shares, price)
        self.factor = factor

    def cost(self):
        return self.factor * super().cost()
```

Ви повинні викликати метод `__init__()` на `super`, який є способом виклику попередньої версії, як показано раніше.

### Використання успадкування

Успадкування іноді використовується для організації пов'язаних об'єктів.
```python
class Shape:
    ...

class Circle(Shape):
    ...

class Rectangle(Shape):
    ...
```

Подумайте про логічну ієрархію або таксономію. Однак більш поширене (і практичне) використання пов’язане зі створенням багаторазового або розширюваного коду. Наприклад, фреймворк може визначати базовий клас і наказувати вам налаштувати його.

```python
class CustomHandler(TCPHandler):
    def handle_request(self):
        ...
        # Спеціальна обробка
```

Базовий клас містить код загального призначення.
Ваш клас успадковує та налаштовує певні частини.

### "є" відносини

Успадкування встановлює зв'язок по типу.

```python
class Shape:
    ...

class Circle(Shape):
    ...
```

Перевірити екземпляр об’єкта.

```python
>>> c = Circle(4.0)
>>> isinstance(c, Shape)
True
>>>
```

*Важливо: в ідеалі будь-який код, який працював з екземплярами батьківського класу, також працюватиме з екземплярами дочірнього класу.*

### базовий клас `object`

Якщо клас не має батьківського елемента, ви іноді бачите `object`, який використовується як база.

```python
class Shape(object):
    ...
```

`object` є батьківським класом для всіх об'єктів у Python.

*Примітка:* це не є технічно обов’язковим, але ви часто бачите, що його вказують як утримку від обов’язкового використання в Python 2. Якщо уникнути, клас все одно неявно успадковується від `object`.

### Множинне успадкування

Ви можете успадкувати від кількох класів, вказавши їх у визначенні класу.

```python
class Mother:
    ...

class Father:
    ...

class Child(Mother, Father):
    ...
```

Клас `Child` успадковує особливості від обох батьків. Є досить хитрі деталі. Не робіть цього, якщо не знаєте, що робите. Деяка додаткова інформація буде надана в наступному розділі, але ми не збираємося використовувати множинне успадкування далі в цьому курсі.

## Вправи

Основне використання успадкування полягає в написанні коду, який має бути розширений або налаштований різними способами, особливо в бібліотеках або фреймворках. Для ілюстрації розглянемо функцію `print_report()` у вашій програмі `report.py`. Це має виглядати приблизно так:

```python
def print_report(reportdata):
    '''
    Надрукувати гарно відформатовану таблицю зі списку таплів (назва, акції, ціна, зміна).
    '''
    headers = ('Name','Shares','Price','Change')
    print('%10s %10s %10s %10s' % headers)
    print(('-'*10 + ' ')*len(headers))
    for row in reportdata:
        print('%10s %10d %10.2f %10.2f' % row)
```

Коли ви запускаєте свою програму звітів, ви маєте отримати такі результати:

```
>>> import report
>>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
```

### Вправа 4.5: Проблема розширюваності

Припустімо, що ви хочете змінити функцію `print_report()` для підтримки різноманітних форматів виводу, таких як звичайний текст, HTML, CSV або XML. Для цього ви можете спробувати написати одну гігантську функцію, яка робила б усе. Однак це, ймовірно, призведе до неремонтованого безладу. Натомість це ідеальна можливість використати успадкування.

Для початку зосередьтеся на етапах створення таблиці. У верхній частині таблиці знаходиться набір заголовків таблиці. Після цього з'являються рядки даних таблиці. Давайте зробимо ці кроки та розмістимо їх у окремому класі. Створіть файл під назвою `tableformat.py` і визначте такий клас:

```python
# tableformat.py

class TableFormatter:
    def headings(self, headers):
        '''
        Видати заголовки таблиці.
        '''
	raise NotImplementedError()

    def row(self, rowdata):
        '''
        Вивести один рядок даних таблиці.
        '''
	raise NotImplementedError()
```

Цей клас нічого не робить, але він служить свого роду специфікацією дизайну для додаткових класів, які будуть визначені незабаром. Такий клас іноді називають «абстрактним базовим класом».

Змініть функцію `print_report()` так, щоб вона приймала об’єкт `TableFormatter` як вхідні дані та викликала його методи для створення виводу. Наприклад, так:

```python
# report.py
...

def print_report(reportdata, formatter):
    '''
    Надрукуйте гарно відформатовану таблицю зі списку таплів (назва, акції, ціна, зміна).
    '''
    formatter.headings(['Name','Shares','Price','Change'])
    for name, shares, price, change in reportdata:
        rowdata = [ name, str(shares), f'{price:0.2f}', f'{change:0.2f}' ]
        formatter.row(rowdata)
```

Оскільки ви додали аргумент для print_report(), вам також потрібно буде змінити функцію `portfolio_report()`. Змініть його так, щоб він створював `TableFormatter` ось так:

```python
# report.py

import tableformat

...
def portfolio_report(portfoliofile, pricefile):
    '''
    Зробіть звіт про акції, враховуючи портфоліо та файли даних про ціни.
    '''
    # Читання файлів даних
    portfolio = read_portfolio(portfoliofile)
    prices = read_prices(pricefile)

    # Створення дані звіту
    report = make_report_data(portfolio, prices)

    # Вивести
    formatter = tableformat.TableFormatter()
    print_report(report, formatter)
```

Запустіть цей новий код:

```python
>>> ================================ RESTART ================================
>>> import report
>>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
... crashes ...
```

Він повинен негайно завершити роботу з винятком `NotImplementedError`. Це не надто захоплююче, але це саме те, чого ми очікували. Перейдіть до наступної частини.

### Вправа 4.6: Використання успадкування для створення іншого результату

Клас `TableFormatter`, який ви визначили в частині (a), призначений для розширення через успадкування. Власне, в цьому і вся ідея. Для ілюстрації визначте клас `TextTableFormatter` так:

```python
# tableformat.py
...
class TextTableFormatter(TableFormatter):
    '''
    Видайте таблицю у форматі звичайного тексту
    '''
    def headings(self, headers):
        for h in headers:
            print(f'{h:>10s}', end=' ')
        print()
        print(('-'*10 + ' ')*len(headers))

    def row(self, rowdata):
        for d in rowdata:
            print(f'{d:>10s}', end=' ')
        print()
```

Змініть функцію `portfolio_report()` таким чином і спробуйте:

```python
# report.py
...
def portfolio_report(portfoliofile, pricefile):
    '''
    Зробіть звіт про акції, враховуючи портфоліо та файли даних про ціни.
    '''
    # Читання файлів даних
    portfolio = read_portfolio(portfoliofile)
    prices = read_prices(pricefile)

    # Створити дані звіту
    report = make_report_data(portfolio, prices)

    # Вивести
    formatter = tableformat.TextTableFormatter()
    print_report(report, formatter)
```

Результат має бути таким же, як і раніше:

```python
>>> ================================ RESTART ================================
>>> import report
>>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
>>>
```

Однак давайте змінимо вихід на щось інше. Визначте новий клас `CSVTableFormatter`, який створює вивід у форматі CSV:

```python
# tableformat.py
...
class CSVTableFormatter(TableFormatter):
    '''
    Виведіть дані портфоліо у форматі CSV.
    '''
    def headings(self, headers):
        print(','.join(headers))

    def row(self, rowdata):
        print(','.join(rowdata))
```

Змініть свою основну програму наступним чином:

```python
def portfolio_report(portfoliofile, pricefile):
    '''
    Зробіть звіт про акції, враховуючи портфоліо та файли даних про ціни.
    '''
    # Читання файлів даних
    portfolio = read_portfolio(portfoliofile)
    prices = read_prices(pricefile)

    # Створити дані звіту
    report = make_report_data(portfolio, prices)

    # Вивести
    formatter = tableformat.CSVTableFormatter()
    print_report(report, formatter)
```

Тепер ви маєте побачити такий вихід CSV:

```python
>>> ================================ RESTART ================================
>>> import report
>>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
Name,Shares,Price,Change
AA,100,9.22,-22.98
IBM,50,106.28,15.18
CAT,150,35.46,-47.98
MSFT,200,20.89,-30.34
GE,95,13.48,-26.89
MSFT,50,20.89,-44.21
IBM,100,106.28,35.84
```

Використовуючи подібну ідею, визначте клас `HTMLTableFormatter`, який створить таблицю з таким результатом:

```
<tr><th>Name</th><th>Shares</th><th>Price</th><th>Change</th></tr>
<tr><td>AA</td><td>100</td><td>9.22</td><td>-22.98</td></tr>
<tr><td>IBM</td><td>50</td><td>106.28</td><td>15.18</td></tr>
<tr><td>CAT</td><td>150</td><td>35.46</td><td>-47.98</td></tr>
<tr><td>MSFT</td><td>200</td><td>20.89</td><td>-30.34</td></tr>
<tr><td>GE</td><td>95</td><td>13.48</td><td>-26.89</td></tr>
<tr><td>MSFT</td><td>50</td><td>20.89</td><td>-44.21</td></tr>
<tr><td>IBM</td><td>100</td><td>106.28</td><td>35.84</td></tr>
```

Перевірте свій код, змінивши основну програму для створення об’єкта `HTMLTableFormatter` замість об’єкта `CSVTableFormatter`.

### Вправа 4.7: Поліморфізм у дії

Основна особливість об’єктно-орієнтованого програмування полягає в тому, що ви можете підключити об’єкт до програми, і вона працюватиме без необхідності змінювати існуючий код. Наприклад, якщо ви написали програму, яка передбачає використання об’єкта `TableFormatter`, вона працюватиме незалежно від того, який тип `TableFormatter` ви їй насправді дали. Таку поведінку іноді називають «поліморфізмом».

Однією з потенційних проблем є з’ясування того, як дозволити користувачеві вибрати потрібний форматер. Пряме використання імен класів, таких як `TextTableFormatter`, часто дратує. Таким чином, ви можете розглянути якийсь спрощений підхід. Можливо, ви вбудуєте оператор `if` у код так:

```python
def portfolio_report(portfoliofile, pricefile, fmt='txt'):
    '''
    Зробіть звіт про акції, враховуючи портфоліо та файли даних про ціни.
    '''
    # Читання файлів даних
    portfolio = read_portfolio(portfoliofile)
    prices = read_prices(pricefile)

    # Створити дані звіту
    report = make_report_data(portfolio, prices)

    # Вивести
    if fmt == 'txt':
        formatter = tableformat.TextTableFormatter()
    elif fmt == 'csv':
        formatter = tableformat.CSVTableFormatter()
    elif fmt == 'html':
        formatter = tableformat.HTMLTableFormatter()
    else:
        raise RuntimeError(f'Unknown format {fmt}')
    print_report(report, formatter)
```

У цьому коді користувач вказує спрощену назву, наприклад `'txt'` або `'csv'`, щоб вибрати формат. Однак чи найкраща ідея розміщувати такий великий оператор `if` у функції `portfolio_report()`? Можливо, було б краще перемістити цей код до функції загального призначення в інше місце.

У файл `tableformat.py` додайте функцію `create_formatter(name)`, яка дозволяє користувачеві створювати засіб форматування з такою назвою виводу, як `'txt'`, `'csv'` або `'html'`. Змініть `portfolio_report()` так, щоб він виглядав так:

```python
def portfolio_report(portfoliofile, pricefile, fmt='txt'):
    '''
    Зробіть звіт про акції, враховуючи портфоліо та файли даних про ціни.
    '''
    # Читання файлів даних
    portfolio = read_portfolio(portfoliofile)
    prices = read_prices(pricefile)

    # Створити дані звіту
    report = make_report_data(portfolio, prices)

    # Вивести
    formatter = tableformat.create_formatter(fmt)
    print_report(report, formatter)
```

Спробуйте викликати функцію в різних форматах, щоб переконатися, що вона працює.

### Вправа 4.8: зібрати все разом

Змініть програму `report.py` так, щоб функція `portfolio_report()` приймала додатковий аргумент, який визначає формат виводу. Наприклад:

```python
>>> report.portfolio_report('Data/portfolio.csv', 'Data/prices.csv', 'txt')
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
>>>
```

Змініть основну програму так, щоб можна було задати формат у командному рядку:

```bash
bash $ python3 report.py Data/portfolio.csv Data/prices.csv csv
Name,Shares,Price,Change
AA,100,9.22,-22.98
IBM,50,106.28,15.18
CAT,150,35.46,-47.98
MSFT,200,20.89,-30.34
GE,95,13.48,-26.89
MSFT,50,20.89,-44.21
IBM,100,106.28,35.84
bash $
```

### Обговорення

Написання розширюваного коду є одним із найпоширеніших застосувань успадкування в бібліотеках і фреймворках. Наприклад, фреймворк може наказати вам визначити власний об’єкт, який успадковує наданий базовий клас. Потім вам буде запропоновано заповнити різні методи, які реалізують різні біти функціональності.

Інша дещо глибша концепція — це ідея «володіти своїми абстракціями». У вправах ми визначили *власний клас* для форматування таблиці. Ви можете подивитись на свій код і сказати собі: «Мені варто просто використати бібліотеку форматування або щось, що вже створив хтось інший!» Ні, ви повинні використовувати І свій клас, і бібліотеку. Використання власного класу сприяє слабкому зв’язку та є більш гнучким. Поки ваша програма використовує інтерфейс програмування вашого класу, ви можете змінити внутрішню реалізацію, щоб вона працювала будь-яким способом. Ви можете написати повністю власний код. Ви можете використовувати чийсь сторонній пакет. Ви міняєте один сторонній пакет на інший, коли знаходите кращий. Це не має значення - жоден код вашої програми не буде зламаний, доки ви збережете інтерфейс. Це потужна ідея, і це одна з причин
ви можете розглянути спадщину для чогось подібного.

Проте розробка об’єктно-орієнтованих програм може бути надзвичайно складною. Для отримання додаткової інформації вам, ймовірно, слід шукати книги на тему шаблонів проектування (хоча розуміння того, що сталося в цій вправі, заведе вас досить далеко в плані використання об’єктів у практично корисний спосіб).


[Зміст](../Contents.md) \| [Попередній розділ (4.1. Класи)](01_Class.md) \| [Наступний розділ (4.3. Спеціальні методи)](03_Special_methods.md)