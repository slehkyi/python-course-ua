[Зміст](../Contents.md) \| [Попередній розділ (3.2. Докладніше про функції)](02_More_functions.md) \| [Наступний розділ (3.4. Модулі)](04_Modules.md)

# 3.3 Перевірка помилок

Незважаючи на те, що винятки були введені раніше, цей розділ містить деякі додаткові відомості про перевірку помилок і обробку винятків.

### Як програми виходять з ладу

Python не виконує перевірку типів або значень аргументів функції. Функція працюватиме з будь-якими даними, які сумісні з операторами у функції.

```python
def add(x, y):
    return x + y

add(3, 4)               # 7
add('Hello', 'World')   # 'HelloWorld'
add('3', '4')           # '34'
```

Якщо у функції є помилки, вони з’являються під час виконання (як виняток).

```python
def add(x, y):
    return x + y

>>> add(3, '4')
Traceback (most recent call last):
...
TypeError: unsupported operand type(s) for +:
'int' and 'str'
>>>
```

Для перевірки коду особливий наголос приділяється тестуванню (розглянемо пізніше).

### Винятки

Винятки використовуються для сигналізації про помилки. Щоб самостійно викликати виключення, скористайтеся оператором `raise`.

```python
if name not in authorized:
    raise RuntimeError(f'{name} not authorized')
```

Щоб перехопити (або зловити) виняток, використовуйте `try-except`.

```python
try:
    authenticate(username)
except RuntimeError as e:
    print(e)
```

### Обробка винятків

Винятки поширюються на перший `except`.

```python
def grok():
    ...
    raise RuntimeError('Whoa!')   # Виняток піднято тут

def spam():
    grok()                        # Виклик, який спричинить виняток

def bar():
    try:
       spam()
    except RuntimeError as e:     # Виняток спійманий тут
        ...

def foo():
    try:
         bar()
    except RuntimeError as e:     # Виняток сюди НЕ добирається
        ...

foo()
```

Щоб обробити виняток, помістіть оператори в блок `except`. Ви можете додати будь-які оператори, якими ви хочете обробити помилку.

```python
def grok(): ...
    raise RuntimeError('Whoa!')

def bar():
    try:
      grok()
    except RuntimeError as e:   # Тут виявлено виняток
        statements              # Використовуйте ці твердження
        statements
        ...

bar()
```

Після обробки виконання поновлюється з першого оператора після `try-except`.

```python
def grok(): ...
    raise RuntimeError('Whoa!')

def bar():
    try:
      grok()
    except RuntimeError as e:   # Тут виявлено виняток
        statements
        statements
        ...
    statements                  # Відновлює виконання тут
    statements                  # І продовжується тут
    ...

bar()
```

### Вбудовані винятки

Є близько двох десятків вбудованих винятків. Зазвичай назва винятку вказує на те, що сталося не так (наприклад, виникає помилка `ValueError`, оскільки ви вказали неправильне значення). Це не вичерпний список. Перевірте [документацію](https://docs.python.org/3/library/exceptions.html) щоб дізнатися більше.

```python
ArithmeticError
AssertionError
EnvironmentError
EOFError
ImportError
IndexError
KeyboardInterrupt
KeyError
MemoryError
NameError
ReferenceError
RuntimeError
SyntaxError
SystemError
TypeError
ValueError
```

### Виняткові значення

Винятки мають відповідне значення. Вони містять більш конкретну інформацію про те, що не так.

```python
raise RuntimeError('Invalid user name')
```

Це значення є частиною екземпляра винятку, який розміщується в змінній, наданій у `except`.
```python
try:
    ...
except RuntimeError as e:   # `e` утримує виключення
    ...
```

`e` є екземпляром типу "виняток". Однак надрукований він часто виглядає як звичайний рядок.

```python
except RuntimeError as e:
    print('Failed : Reason', e)
```

### Виявлення кількох помилок

Ви можете перехоплювати різні види винятків, використовуючи кілька блоків `except`.

```python
try:
  ...
except LookupError as e:
  ...
except RuntimeError as e:
  ...
except IOError as e:
  ...
except KeyboardInterrupt as e:
  ...
```

Крім того, якщо оператори для їх обробки однакові, ви можете згрупувати їх:

```python
try:
  ...
except (IOError,LookupError,RuntimeError) as e:
  ...
```

### Виявлення всіх помилок

Щоб перехопити будь-який виняток, використовуйте `Exception` так:

```python
try:
    ...
except Exception:       # НЕБЕЗПЕКА. Дивіться нижче
    print('An error occurred')
```

Загалом, писати такий код — погана ідея, тому що ви не будете знати, звідки взялася помилка.

### Неправильний спосіб ловити помилки

Ось неправильний спосіб використання винятків.

```python
try:
    go_do_something()
except Exception:
    print('Computer says no')
```

Це вловлює всі можливі помилки та може унеможливити налагодження, коли код не працює з якоїсь причини, якої ви взагалі не очікували (наприклад, видалений модуль Python тощо).

### Дещо кращий підхід

Якщо ви збираєтеся виловлювати всі помилки, це більш розумний підхід.

```python
try:
    go_do_something()
except Exception as e:
    print('Computer says no. Reason :', e)
```

Він повідомляє про конкретну причину невдачі. Майже завжди доцільно мати якийсь механізм для перегляду/повідомлення про помилки, коли ви пишете код, який вловлює всі можливі винятки.

Загалом, краще вловити помилку настільки вузько, наскільки це розумно. Виловлюйте лише ті помилки, з якими справді можете впоратися. Нехай інші помилки обходять стороною - можливо, якийсь інший код впорається з ними.

### Повторне створення винятку

Використовуйте `raise` для поширення виявленої помилки.

```python
try:
    go_do_something()
except Exception as e:
    print('Computer says no. Reason :', e)
    raise
```

Це дозволяє вжити заходів (наприклад, зареєструвати) і передати помилку попередній функції.

### Рекомендації щодо винятків

Не ловіть винятки. Краще швидкий і гучний провал. Якщо це важливо, хтось інший подбає про проблему. Ловіть виняток, лише якщо ви *це* хтось. Тобто виловлюйте лише ті помилки, які ви можете виправити та спокійно продовжувати.

### Оператор `finally`

Він визначає код, який має виконуватися незалежно від того, чи виникає виняткова ситуація.

```python
lock = Lock()
...
lock.acquire()
try:
    ...
finally:
    lock.release()  # це ЗАВЖДИ виконуватиметься. З винятком і без винятку.
```

Зазвичай використовується для безпечного керування ресурсами (особливо замками, файлами тощо).

### Оператор `with`

У сучасному коді `try-finally` часто замінюється оператором `with`.

```python
lock = Lock()
with lock:
    # lock acquired
    ...
# lock released
```

Більш знайомий приклад:

```python
with open(filename) as f:
    # Use the file
    ...
# File closed
```

`with` визначає *контекст* використання для ресурсу. Коли виконання залишає цей контекст, ресурси звільняються. `with` працює лише з певними об’єктами, які були спеціально запрограмовані для його підтримки.

## Вправи

### Вправа 3.8: Створення винятків

Функція `parse_csv()`, яку ви написали в останньому розділі, дозволяє вибирати вказані користувачем стовпці, але це працює, лише якщо файл вхідних даних має заголовки стовпців.

Змініть код так, щоб виняток викликався, якщо передано аргументи `select` і `has_headers=False`. Наприклад:
```python
>>> parse_csv('Data/prices.csv', select=['name','price'], has_headers=False)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "fileparse.py", line 9, in parse_csv
    raise RuntimeError("select argument requires column headers")
RuntimeError: select argument requires column headers
>>>
```

Додавши цю одну перевірку, ви можете запитати, чи слід виконувати інші види перевірок працездатності у функції. Наприклад, чи варто перевіряти, чи ім’я файлу є рядком, типи – списком або щось подібне?

Як правило, найкраще пропустити такі тести та просто дозволити програмі вийти з ладу через неправильні вхідні дані. Повідомлення відстеження вказує на джерело проблеми та може допомогти у налагодженні.

Основна причина додавання наведеної вище перевірки полягає в тому, щоб уникнути запуску коду в безглуздому режимі (наприклад, використання функції, яка вимагає заголовків стовпців, але одночасно вказує, що заголовків немає).

Це вказує на помилку програмування в коді виклику. Перевірка випадків, які «не повинні відбуватися», часто є гарною ідеєю.

### Вправа 3.9: Перехоплення винятків

Написана вами функція `parse_csv()` використовується для обробки всього вмісту файлу. Однак у реальному світі можливо, що вхідні файли можуть містити пошкоджені, відсутні або брудні дані. Спробуйте цей експеримент:

```python
>>> portfolio = parse_csv('Data/missing.csv', types=[str, int, float])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "fileparse.py", line 36, in parse_csv
    row = [func(val) for func, val in zip(types, row)]
ValueError: invalid literal for int() with base 10: ''
>>>
```

Змініть функцію `parse_csv()`, щоб перехоплювати всі винятки `ValueError`, створені під час створення запису, і друкувати попередження для рядків, які не можна обробити.

Повідомлення має містити номер рядка та інформацію про причину невдачі. Щоб перевірити свою функцію, спробуйте прочитати файл `Data/missing.csv` вище. Наприклад:
```python
>>> portfolio = parse_csv('Data/missing.csv', types=[str, int, float])
Row 4: Couldn't convert ['MSFT', '', '51.23']
Row 4: Reason invalid literal for int() with base 10: ''
Row 7: Couldn't convert ['IBM', '', '70.44']
Row 7: Reason invalid literal for int() with base 10: ''
>>>
>>> portfolio
[{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}]
>>>
```

### Вправа 3.10: Замовчування помилок

Змініть функцію `parse_csv()` так, щоб повідомлення про помилки синтаксичного аналізу можна було вимкнути, якщо це явно забажає користувач. Наприклад:
```python
>>> portfolio = parse_csv('Data/missing.csv', types=[str,int,float], silence_errors=True)
>>> portfolio
[{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}]
>>>
```
Обробка помилок є однією з найскладніших речей, які потрібно виправити в більшості програм. Як правило, ви не повинні мовчки ігнорувати помилки. Натомість краще повідомити про проблеми та надати користувачеві можливість вимкнути повідомлення про помилку, якщо він захоче це зробити.

[Зміст](../Contents.md) \| [Попередній розділ (3.2. Докладніше про функції)](02_More_functions.md) \| [Наступний розділ (3.4. Модулі)](04_Modules.md)
