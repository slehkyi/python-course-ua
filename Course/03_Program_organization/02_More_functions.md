[Зміст](../Contents.md) \| [Попередній розділ (3.1. Функції та написання скриптів)](01_Script.md) \| [Наступний розділ (3.3. Обробка винятків)](03_Error_checking.md)

# 3.2 Докладніше про функції

Хоча функції були представлені раніше, було надано дуже мало деталей про те, як вони насправді працюють на глибшому рівні. Цей розділ має на меті заповнити деякі прогалини та обговорити такі питання, як правила виклику функцій, визначення області дії тощо.

### Виклик функції

Розглянемо цю функцію:

```python
def read_prices(filename, debug):
    ...
```

Ви можете викликати функцію з позиційними аргументами:

```
prices = read_prices('prices.csv', True)
```

Або ви можете викликати функцію з ключовими аргументами:

```python
prices = read_prices(filename='prices.csv', debug=True)
```

### Аргументи за замовчуванням

Іноді хочеться, щоб аргумент був необов’язковим. Якщо так, призначте значення за умовчанням у визначенні функції.

```python
def read_prices(filename, debug=False):
    ...
```

Якщо присвоєно значення за замовчуванням, аргумент є необов’язковим у викликах функцій.
```python
d = read_prices('prices.csv')
e = read_prices('prices.dat', True)
```

*Примітка. Аргументи зі значеннями за замовчуванням мають відображатися в кінці списку аргументів (усі необов’язкові аргументи йдуть першими).*

### Віддавати перевагу аргументам ключових слів замість необов’язкових

Порівняйте ці два різні стилі виклику:

```python
parse_data(data, False, True) # ?????

parse_data(data, ignore_errors=True)
parse_data(data, debug=True)
parse_data(data, debug=True, ignore_errors=True)
```

У більшості випадків аргументи ключових слів покращують чіткість коду - особливо для аргументів, які служать прапорцями або які пов'язані з необов'язковими функціями.

### Найкращі практики дизайну

Завжди давайте короткі, але змістовні імена аргументам функцій.

Хтось, хто використовує функцію, може захотіти використовувати стиль виклику ключового слова.

```python
d = read_prices('prices.csv', debug=True)
```

Інструменти розробки Python відображатимуть назви в довідкових функціях і документації.

### Значення, що повертаються

Оператор `return` повертає значення

```python
def square(x):
    return x * x
```

Якщо значення, що повертається, не вказано або `return` відсутній, повертається `None`.

```python
def bar(x):
    statements
    return

a = bar(4)      # a = None

# OR
def foo(x):
    statements  # No `return`

b = foo(4)      # b = None
```

### Кілька значень, що повертаються

Функції можуть повертати лише одне значення. Однак функція може повертати кілька значень, повертаючи їх у вигляді таплу.
```python
def divide(a,b):
    q = a // b      # Quotient
    r = a % b       # Remainder
    return q, r     # Return a tuple
```

Приклад використання:
```python
x, y = divide(37,5) # x = 7, y = 2

x = divide(37, 5)   # x = (7, 2)
```

### Область дії змінної

Програми присвоюють значення змінним.

```python
x = value # Глобальна змінна

def foo():
    y = value # Локальна змінна
```

Присвоєння змінним відбувається поза та всередині визначення функції. Змінні, визначені зовні, є "глобальними". Змінні всередині функції є "локальними".

### Локальні змінні

Змінні, призначені всередині функції, є приватними.

```python
def read_portfolio(filename):
    portfolio = []
    for line in open(filename):
        fields = line.split(',')
        s = (fields[0], int(fields[1]), float(fields[2]))
        portfolio.append(s)
    return portfolio
```

У цьому прикладі `filename`, `portfolio`, `line`, `fields` і `s` є локальними змінними. Ці змінні не зберігаються та не доступні після виклику функції.

```python
>>> stocks = read_portfolio('portfolio.csv')
>>> fields
Traceback (most recent call last):
File "<stdin>", line 1, in ?
NameError: name 'fields' is not defined
>>>
```

Місцеві змінні також не можуть конфліктувати зі змінними, знайденими деінде.

### Глобальні змінні

Функції можуть вільно отримувати доступ до значень глобалів, визначених у тому самому файлі.

```python
name = 'Dave'

def greeting():
    print('Hello', name)  # Використовуючи глобальну змінну `name`
```

Однак функції не можуть змінювати глобальні змінні:
```python
name = 'Dave'

def spam():
  name = 'Guido'

spam()
print(name) # prints 'Dave'
```

**Пам’ятайте: усі призначення у функціях локальні.**

### Зміна глобалів

Якщо вам потрібно змінити глобальну змінну, ви повинні оголосити її як таку.
```python
name = 'Dave'

def spam():
    global name
    name = 'Guido' # Changes the global name above
```

Глобальна декларація має з’явитися перед її використанням, а відповідна змінна має існувати в тому самому файлі, що й функція. Побачивши це, знайте, що це вважається поганою формою. Насправді, намагайтеся повністю уникати `глобальних змінних`, якщо можете. Якщо вам потрібна функція для зміни якогось стану поза цією функцією, замість цього краще використовувати клас (докладніше про це пізніше).

### Передача аргументу

Коли ви викликаєте функцію, змінні аргументів є іменами, які посилаються на передані значення. Ці значення НЕ є копіями (див. [розділ 2.7](../02_Working_with_data/07_Objects)). Якщо передано змінні типи даних (наприклад, списки, словники), їх можна змінити *на місці*.

```python
def foo(items):
    items.append(42)    # Змінює вхідний об'єкт

a = [1, 2, 3]
foo(a)
print(a)                # [1, 2, 3, 42]
```

**Ключовий момент: функції не отримують копію вхідних аргументів.**

### Перепризначення чи зміна

Переконайтеся, що ви розумієте тонку різницю між зміною значення та перепризначенням імені змінної.

```python
def foo(items):
    items.append(42)    # Modifies the input object

a = [1, 2, 3]
foo(a)
print(a)                # [1, 2, 3, 42]

# VS
def bar(items):
    items = [4,5,6]    # Змінює локальну змінну `items`, щоб вказувати на інший об’єкт

b = [1, 2, 3]
bar(b)
print(b)                # [1, 2, 3]
```

*Нагадування: призначення змінної ніколи не перезаписує пам’ять. Ім’я просто прив’язане до нового значення.*

## Вправи

У цьому комплексі вправ ви реалізуєте, мабуть, найсильнішу та найскладнішу частину курсу. Тут багато кроків і багато концепцій з минулих вправ зібрані разом. Остаточне рішення складається лише з 25 рядків коду, але не поспішайте й переконайтеся, що ви розумієте кожну частину.

Центральна частина вашої програми `report.py` зосереджена на читанні файлів CSV. Наприклад, функція `read_portfolio()` читає файл, що містить рядки даних портфоліо, а функція `read_prices()` читає файл, що містить рядки даних про ціни. В обох цих функціях є багато низькорівневих «непоганих» частин і подібних функцій. Наприклад, вони обидві відкривають файл і обгортають його модулем `csv`, і вони обидві перетворюють різні поля на нові типи.

Якби ви справді багато аналізували файли, ви, мабуть, захочете очистити щось із цього та зробити його більш загальним. Це наша ціль.

Почніть цю вправу, відкривши файл під назвою `Work/fileparse.py`. Тут ми будемо виконувати свою роботу.

### Вправа 3.3: Читання файлів CSV

Для початку давайте просто зосередимося на проблемі читання файлу CSV у списку словників. У файлі `fileparse.py` визначте функцію, яка виглядає так:

```python
# fileparse.py
import csv

def parse_csv(filename):
    '''
    Parse a CSV file into a list of records
    '''
    with open(filename) as f:
        rows = csv.reader(f)

        # Зчитати заголовки
        headers = next(rows)
        records = []
        for row in rows:
            if not row:    # Пропустити пустий рядок
                continue
            record = dict(zip(headers, row))
            records.append(record)

    return records
```

Ця функція зчитує файл CSV у список словників, приховуючи деталі відкриття файлу, обгортаючи його модулем `csv`, ігноруючи порожні рядки тощо.

Спробуйте. Підказка: `python3 -i fileparse.py`.

```python
>>> portfolio = parse_csv('Data/portfolio.csv')
>>> portfolio
[{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}]
>>>
```

Це все ОК, за винятком того, що ви не можете виконувати якісь корисні обчислення з даними, оскільки все представлено у вигляді рядка. Невдовзі ми виправимо це, але давайте продовжувати розвивати дану програму.

### Вправа 3.4: Створення селектора стовпців

У багатьох випадках вас цікавлять лише вибрані стовпці з файлу CSV, а не всі дані. Змініть функцію `parse_csv()` так, щоб вона додатково дозволяла вибирати вказані користувачем стовпці таким чином:

```python
>>> # Зчитати всі дані
>>> portfolio = parse_csv('Data/portfolio.csv')
>>> portfolio
[{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}]

>>> # Зчитати частину даних
>>> shares_held = parse_csv('Data/portfolio.csv', select=['name','shares'])
>>> shares_held
[{'name': 'AA', 'shares': '100'}, {'name': 'IBM', 'shares': '50'}, {'name': 'CAT', 'shares': '150'}, {'name': 'MSFT', 'shares': '200'}, {'name': 'GE', 'shares': '95'}, {'name': 'MSFT', 'shares': '50'}, {'name': 'IBM', 'shares': '100'}]
>>>
```

Приклад селектора стовпців наведено у [вправі 2.23](../02_Working_with_data/06_List_comprehension).
Однак ось ще один спосіб зробити його:

```python
# fileparse.py
import csv

def parse_csv(filename, select=None):
    '''
    Parse a CSV file into a list of records
    '''
    with open(filename) as f:
        rows = csv.reader(f)

        # Зчитати заголовки
        headers = next(rows)

        # Якщо задано селектор стовпців, знайдіть індекси вказаних стовпців.
        # Також звузіть набір заголовків, які використовуються для кінцевих словників
        if select:
            indices = [headers.index(colname) for colname in select]
            headers = select
        else:
            indices = []

        records = []
        for row in rows:
            if not row:    # Пропустити рядки без даних
                continue
            # Відфільтрувати рядок, якщо вибрано певні стовпці
            if indices:
                row = [ row[index] for index in indices ]

            # Створити словник
            record = dict(zip(headers, row))
            records.append(record)

    return records
```

У цій частині є кілька складних моментів. Ймовірно, найважливішим є відображення вибраних стовпців на індекси рядків. Наприклад, припустимо, що вхідний файл мав такі заголовки:

```python
>>> headers = ['name', 'date', 'time', 'shares', 'price']
>>>
```

Тепер припустімо, що вибрані стовпці були такими:

```python
>>> select = ['name', 'shares']
>>>
```

Щоб виконати правильний вибір, вам потрібно зіставити назви вибраних стовпців з індексами стовпців у файлі. Ось що робить цей крок:

```python
>>> indices = [headers.index(colname) for colname in select ]
>>> indices
[0, 3]
>>>
```

Іншими словами, «name» — це стовпець 0, а «shares» — стовпець 3. Коли ви читаєте рядок даних із файлу, для його фільтрації використовуються індекси:

```python
>>> row = ['AA', '6/11/2007', '9:50am', '100', '32.20' ]
>>> row = [ row[index] for index in indices ]
>>> row
['AA', '100']
>>>
```

### Вправа 3.5: Виконання перетворення типів

Змініть функцію parse_csv() так, щоб вона опціонально дозволяла застосовувати перетворення типів до повернених даних. Наприклад:

```python
>>> portfolio = parse_csv('Data/portfolio.csv', types=[str, int, float])
>>> portfolio
[{'price': 32.2, 'name': 'AA', 'shares': 100}, {'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}, {'price': 40.37, 'name': 'GE', 'shares': 95}, {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}]

>>> shares_held = parse_csv('Data/portfolio.csv', select=['name', 'shares'], types=[str, int])
>>> shares_held
[{'name': 'AA', 'shares': 100}, {'name': 'IBM', 'shares': 50}, {'name': 'CAT', 'shares': 150}, {'name': 'MSFT', 'shares': 200}, {'name': 'GE', 'shares': 95}, {'name': 'MSFT', 'shares': 50}, {'name': 'IBM', 'shares': 100}]
>>>
```

Ви вже досліджували це у [вправі 2.24](../02_Working_with_data/07_Objects). Вам потрібно буде вставити такий фрагмент коду у своє рішення:

```python
...
if types:
    row = [func(val) for func, val in zip(types, row) ]
...
```

### Вправа 3.6: Робота без заголовків

Деякі файли CSV не містять жодної інформації заголовка. Наприклад, файл `prices.csv` виглядає так:

```csv
"AA",9.22
"AXP",24.85
"BA",44.85
"BAC",11.27
...
```

Змініть функцію `parse_csv()` так, щоб вона могла працювати з такими файлами, створивши натомість список таплів. Наприклад:
```python
>>> prices = parse_csv('Data/prices.csv', types=[str,float], has_headers=False)
>>> prices
[('AA', 9.22), ('AXP', 24.85), ('BA', 44.85), ('BAC', 11.27), ('C', 3.72), ('CAT', 35.46), ('CVX', 66.67), ('DD', 28.47), ('DIS', 24.22), ('GE', 13.48), ('GM', 0.75), ('HD', 23.16), ('HPQ', 34.35), ('IBM', 106.28), ('INTC', 15.72), ('JNJ', 55.16), ('JPM', 36.9), ('KFT', 26.11), ('KO', 49.16), ('MCD', 58.99), ('MMM', 57.1), ('MRK', 27.58), ('MSFT', 20.89), ('PFE', 15.19), ('PG', 51.94), ('T', 24.79), ('UTX', 52.61), ('VZ', 29.26), ('WMT', 49.74), ('XOM', 69.35)]
>>>
```

Щоб внести цю зміну, вам потрібно буде змінити код так, щоб перший рядок даних не інтерпретувався як рядок заголовка. Крім того, вам потрібно переконатися, що ви не створюєте словники, оскільки більше немає назв стовпців, які можна використовувати як ключі.

### Вправа 3.7: Вибір іншого розділювача стовпців

Хоча файли CSV досить поширені, також можливо, що ви можете зустріти файл, який використовує інший роздільник стовпців, наприклад табуляцію або пробіл. Наприклад, файл `Data/portfolio.dat` виглядає так:
```csv
name shares price
"AA" 100 32.20
"IBM" 50 91.10
"CAT" 150 83.44
"MSFT" 200 51.23
"GE" 95 40.37
"MSFT" 50 65.10
"IBM" 100 70.44
```

Функція `csv.reader()` дозволяє вказати інший роздільник стовпця таким чином:

```python
rows = csv.reader(f, delimiter=' ')
```

Змініть свою функцію `parse_csv()` так, щоб вона також дозволяла змінювати роздільник.

For example:

```python
>>> portfolio = parse_csv('Data/portfolio.dat', types=[str, int, float], delimiter=' ')
>>> portfolio
[{'price': '32.20', 'name': 'AA', 'shares': '100'}, {'price': '91.10', 'name': 'IBM', 'shares': '50'}, {'price': '83.44', 'name': 'CAT', 'shares': '150'}, {'price': '51.23', 'name': 'MSFT', 'shares': '200'}, {'price': '40.37', 'name': 'GE', 'shares': '95'}, {'price': '65.10', 'name': 'MSFT', 'shares': '50'}, {'price': '70.44', 'name': 'IBM', 'shares': '100'}]
>>>
```

### Коментар

Якщо ви зайшли так далеко, ви створили гарну бібліотечну функцію, яка справді корисна. Ви можете використовувати її для аналізу довільних файлів CSV, вибору стовпців, які вас цікавлять, виконання перетворень типів, не надто турбуючись про внутрішню роботу файлів або модуль `csv`.

[Зміст](../Contents.md) \| [Попередній розділ (3.1. Функції та написання скриптів)](01_Script.md) \| [Наступний розділ (3.3. Обробка винятків)](03_Error_checking.md)
