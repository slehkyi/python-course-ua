[Зміст](../Contents.md) \| [Попередній розділ (2.7. Об'єктна модель)](../02_Working_with_data/07_Objects.md) \| [Наступний розділ (3.2. Більше про функції)](02_More_functions.md)

# 3.1 Написання скриптів

У цій частині ми детальніше розглянемо практику написання скриптів Python.

### Що таке скрипт?

*Скрипт* — це програма, яка виконує серію операторів і зупиняється.

```python
# program.py

statement1
statement2
statement3
...
```

До цього моменту ми здебільшого писали скрипти.

### Проблема

Якщо ви напишете корисний скрипт, його функції та функціональність розширяться. Ви зможете застосувати його до інших пов’язаних проблем. З часом він може стати критичним додатком. І якщо ви не подбаєте про організацію елементів всередині програми, вона може перетворитися на величезну і заплутану кашу. Отже, давайте організовуватися.

### Визначення елементів

Імена завжди потрібно визначати, перш ніж використовувати їх пізніше.

```python
def square(x):
    return x*x

a = 42
b = a + 2     # Вимагає, що `a` уже визначено

z = square(b) # Вимагає `square` і `b` визначеними
```

**Порядок важливий.**
Ви майже завжди розміщуєте визначення змінних і функцій у верхній частині.

### Визначення функцій

Бажано розмістити весь код, пов’язаний з одним *завданням*, в одному місці. Використовуйте функцію.
```python
def read_prices(filename):
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
```

Функція також спрощує повторювані операції.
```python
oldprices = read_prices('oldprices.csv')
newprices = read_prices('newprices.csv')
```

### Що таке функція?

Функція — це іменована послідовність операторів.
```python
def funcname(args):
  statement
  statement
  ...
  return result
```

*Будь-який* оператор Python можна використовувати всередині.
```python
def foo():
    import math
    print(math.sqrt(2))
    help(math)
```

У Python немає *спеціальних* операторів (що полегшує запам’ятовування).

### Визначення функції

Функції можна *визначати* в будь-якому порядку.
```python
def foo(x):
    bar(x)

def bar(x):
    statements

# OR
def bar(x):
    statements

def foo(x):
    bar(x)
```

Функції мають бути визначені лише до фактичного *використання* (або виклику) під час виконання програми.

```python
foo(3)        # foo вже повинна існувати
```

Стилістично, ймовірно, більш поширеним є визначення функцій у стилі *знизу-вгору».

### Стиль "знизу вгору".

Функції розглядаються як будівельні блоки. Менші/простіші блоки йдуть першими.

```python
# myprogram.py
def foo(x):
    ...

def bar(x):
    ...
    foo(x)          # Визначено зверху
    ...

def spam(x):
    ...
    bar(x)          # Визначено зверху
    ...

spam(42)            # Код, який використовує функції, з’являється в кінці
```

Пізніші функції будуються на попередніх функціях. Знову ж таки, це лише елемент стилю. Єдине, що має значення у наведеній вище програмі, це те, що виклик `spam(42)` йде останнім.

### Дизайн функцій

В ідеалі функції мають бути *чорним ящиком*. Вони повинні працювати лише на переданих вхідних даних, уникати глобальних змінних і таємничих побічних ефектів. Ваші головні цілі: *Модульність* і *Передбачуваність*.

### Рядки документації

Рекомендується включати документацію у вигляді рядка документа. Док-рядки - це рядки, написані відразу після назви функції. Вони живлять `help()`, IDE та інші інструменти.

```python
def read_prices(filename):
    '''
    Зчитує ціни з CSV-файлу з даними "назва,ціна"
    '''
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
```

Гарною практикою для рядків документа є написання короткого підсумку в одне речення про те, що робить функція. Якщо потрібна додаткова інформація, додайте короткий приклад використання разом із більш детальним описом аргументів.

### Анотації типів

Ви також можете додати додаткові підказки типу до визначень функцій.

```python
def read_prices(filename: str) -> dict:
    '''
    Зчитує ціни з CSV-файлу з даними "назва,ціна"
    '''
    prices = {}
    with open(filename) as f:
        f_csv = csv.reader(f)
        for row in f_csv:
            prices[row[0]] = float(row[1])
    return prices
```

Оперативно підказки нічого не роблять. Вони суто інформаційні. Однак вони можуть використовуватися IDE, засобами перевірки коду та іншими інструментами, щоб зробити більше.

## Вправи

У розділі 2 ви написали програму під назвою `report.py`, яка друкує звіт, що показує продуктивність портфеля акцій. Ця програма складалася з кількох функцій. Наприклад:

```python
# report.py
import csv

def read_portfolio(filename):
    '''
    Зчитує файл портфоліо акцій у списку словників із ключами
    назва, акції та ціна.
    '''
    portfolio = []
    with open(filename) as f:
        rows = csv.reader(f)
        headers = next(rows)

        for row in rows:
            record = dict(zip(headers, row))
            stock = {
                'name' : record['name'],
                'shares' : int(record['shares']),
                'price' : float(record['price'])
            }
            portfolio.append(stock)
    return portfolio
...
```

Однак були також частини програми, які просто виконували серію обчислень за сценарієм. Цей код з'явився в кінці програми. Наприклад:

```python
...

# Вивести звіт

headers = ('Name', 'Shares', 'Price', 'Change')
print('%10s %10s %10s %10s'  % headers)
print(('-' * 10 + ' ') * len(headers))
for row in report:
    print('%10s %10d %10.2f %10.2f' % row)
...
```

У цій вправі ми візьмемо цю програму та організуємо її трохи чіткіше навколо використання функцій.

### Вправа 3.1: Структурування програми як набору функцій

Змініть свою програму `report.py` так, щоб усі основні операції, включно з обчисленнями та виведенням, виконувалися набором функцій. Зокрема:

*Створіть функцію `print_report(report)`, яка друкує звіт.* Змініть останню частину програми так, щоб вона була не чим іншим, як серією викликів функцій і жодним іншим обчисленням.

### Вправа 3.2: Створення функції верхнього рівня для виконання програми

Візьміть останню частину вашої програми та запакуйте її в єдину функцію `portfolio_report(portfolio_filename, prices_filename)`. Нехай функція працює так, щоб наступний виклик функції створював звіт, як і раніше:

```python
portfolio_report('Data/portfolio.csv', 'Data/prices.csv')
```

У цій остаточній версії ваша програма буде нічим іншим, як серією визначень функцій, за якими слідуватиме єдиний виклик функції `portfolio_report()` у самому кінці (який виконує всі кроки, залучені до програми).

Перетворивши вашу програму на одну функцію, її стає легко запускати на різних входах. Наприклад, спробуйте інтерактивно виконати ці оператори після запуску програми:

```python
>>> portfolio_report('Data/portfolio2.csv', 'Data/prices.csv')
... look at the output ...
>>> files = ['Data/portfolio.csv', 'Data/portfolio2.csv']
>>> for name in files:
        print(f'{name:-^43s}')
        portfolio_report(name, 'Data/prices.csv')
        print()

... look at the output ...
>>>
```

### Коментар

Python дозволяє дуже легко писати відносно неструктурований код скриптів, де у вас є лише файл із послідовністю операторів у ньому. У загальному плані майже завжди краще використовувати функції, коли це можливо. У якийсь момент цей сценарій розшириться, і ви побажаєте, щоб у вас було трохи більше організації. Крім того, маловідомий факт полягає в тому, що Python працює трохи швидше, якщо ви використовуєте функції.

[Зміст](../Contents.md) \| [Попередній розділ (2.7. Об'єктна модель)](../02_Working_with_data/07_Objects.md) \| [Наступний розділ (3.2. Більше про функції)](02_More_functions.md)
