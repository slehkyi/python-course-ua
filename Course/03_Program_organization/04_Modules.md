[Зміст](../Contents.md) \| [Попередній розділ (3.3. Перевірка помилок)](03_Error_checking.md) \| [Наступний розділ (3.5. Основний модуль)](05_Main_module.md)

# 3.4 Модулі

У цьому розділі представлено поняття модулів і роботи з функціями, які охоплюють декілька файлів.

### Модулі та імпорт

Будь-який вихідний файл Python є модулем.
```python
# foo.py
def grok(a):
    ...
def spam(b):
    ...
```

Оператор `import` завантажує та *виконує* модуль.

```python
# program.py
import foo

a = foo.grok(2)
b = foo.spam('Hello')
...
```

### Простори імен

Модуль — це набір іменованих значень, який іноді називають *простором імен*. Імена — це всі глобальні змінні та функції, визначені у вихідному файлі. Після імпортування назва модуля використовується як префікс. Звідси і *простір імен*.

```python
import foo

a = foo.grok(2)
b = foo.spam('Hello')
...
```

Назва модуля безпосередньо пов’язана з назвою файлу (foo -> foo.py).

### Глобальні визначення

Все, що визначено в *глобальній* області, є тим, що заповнює простір імен модуля. Розглянемо два модулі, які визначають ту саму змінну `x`.

```python
# foo.py
x = 42
def grok(a):
    ...
```

```python
# bar.py
x = 37
def spam(a):
    ...
```

У цьому випадку визначення `x` стосуються різних змінних. Один — `foo.x`, а інший — `bar.x`. Різні модулі можуть використовувати однакові імена, і ці імена не конфліктуватимуть одне з одним.

**Модулі є ізольованими.**

### Модулі як середовища

Модулі утворюють охоплююче середовище для всього коду, визначеного всередині.

```python
# foo.py
x = 42

def grok(a):
    print(x)
```

*Глобальні* змінні завжди прив’язані до охоплюючого модуля (того самого файлу). Кожен вихідний файл — це власний маленький всесвіт.

### Виконання модуля

Коли модуль імпортовано, *усі оператори в модулі виконуються* один за одним, доки не буде досягнуто кінця файлу. Вміст простору імен модуля — це всі *глобальні* імена, які все ще визначені наприкінці процесу виконання. Якщо є оператори сценаріїв, які виконують завдання в глобальній області (друк, створення файлів тощо), ви побачите, що вони виконуються під час імпорту.

### Оператор `імпортувати як`

Ви можете змінити назву модуля під час його імпорту:

```python
import math as m
def rectangular(r, theta):
    x = r * m.cos(theta)
    y = r * m.sin(theta)
    return x, y
```

Він працює так само, як звичайний імпорт. Він просто перейменовує модуль у цьому файлі.

### Імпорт використовуючи `from`

В цьому випадку вибираються вибрані символи з модуля та робляться доступними локально.

```python
from math import sin, cos

def rectangular(r, theta):
    x = r * cos(theta)
    y = r * sin(theta)
    return x, y
```

Це дозволяє використовувати частини модуля без необхідності вводити префікс модуля. Це корисно для імен, які часто використовуються.

### Коментарі до імпорту

Варіанти імпорту *не* змінюють спосіб роботи модулів.
```python
import math
# vs
import math as m
# vs
from math import cos, sin
...
```

Зокрема, `import` завжди виконує *весь* файл і модулі все ще є ізольованими середовищами.

Оператор `import module as` змінює назву лише локально. Інструкція `from math import cos, sin` все ще завантажує весь математичний модуль за кадром. А потім просто робиться копіювання імен `cos` і `sin` з модуля в локальний простір після завершення.

### Завантаження модуля

Кожен модуль завантажується та виконується лише *один раз*. *Примітка. Повторний імпорт лише повертає посилання на попередньо завантажений модуль.*

`sys.modules` - це словник усіх завантажених модулів.

```python
>>> import sys
>>> sys.modules.keys()
['copy_reg', '__main__', 'site', '__builtin__', 'encodings', 'encodings.encodings', 'posixpath', ...]
>>>
```

**Застереження:** типова плутанина виникає, якщо ви повторюєте оператор `import` після зміни вихідного коду для модуля. Через кеш модуля `sys.modules` повторний імпорт завжди повертає попередньо завантажений модуль, навіть якщо було внесено зміни. Найбезпечніший спосіб завантажити модифікований код у Python — це вийти та перезапустити інтерпретатор.

### Розташування модулів

Під час пошуку модулів Python звертається до списку шляхів (sys.path).
```python
>>> import sys
>>> sys.path
[
  '',
  '/usr/local/lib/python36/python36.zip',
  '/usr/local/lib/python36',
  ...
]
```

Поточний робочий каталог зазвичай є першим.

### Шлях пошуку модуля

Як зазначалося, `sys.path` містить шляхи пошуку. Ви можете налаштувати його вручну, якщо потрібно.

```python
import sys
sys.path.append('/project/foo/pyfiles')
```

Шляхи також можна додавати за допомогою змінних середовища.
```python
% env PYTHONPATH=/project/foo/pyfiles python3
Python 3.6.0 (default, Feb 3 2017, 05:53:21)
[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)]
>>> import sys
>>> sys.path
['','/project/foo/pyfiles', ...]
```

Як правило, немає необхідності вручну налаштовувати шлях пошуку модуля. Однак іноді це виникає, якщо ви намагаєтеся імпортувати код Python, який знаходиться в незвичному місці або недоступний з поточного робочого каталогу.

## Вправи

Для цієї вправи з модулями надзвичайно важливо переконатися, що ви використовуєте Python у належному середовищі. Модулі часто створюють у нових програмістів проблеми, пов’язані з поточним робочим каталогом або налаштуваннями шляху Python. Для цього курсу передбачається, що ви пишете весь свій код у каталозі `Work/`. Щоб отримати найкращі результати, ви повинні переконатися, що ви також перебуваєте в цьому каталозі під час запуску інтерпретатора. Якщо ні, вам потрібно переконатися, що `practical-python/Work` додано до `sys.path`.

### Вправа 3.11: Імпорт модулів

У розділі 3 ми створили функцію загального призначення `parse_csv()` для аналізу вмісту файлів даних CSV.

Тепер ми подивимося, як використовувати цю функцію в інших програмах. Спочатку почніть у новому вікні оболонки. Перейдіть до папки, де зберігаються всі ваші файли. Ми збираємося їх імпортувати.

Запустіть інтерактивний режим Python.
```shell
bash % python3
Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

Зробивши це, спробуйте імпортувати деякі з програм, які ви раніше написали. Ви маєте побачити їх результат точно так само, як і раніше. Треба підкреслити, що імпорт модуля запускає його код.
```python
>>> import bounce
... watch output ...
>>> import mortgage
... watch output ...
>>> import report
... watch output ...
>>>
```

Якщо нічого з цього не працює, можливо, ви використовуєте Python у неправильному каталозі. Тепер спробуйте імпортувати свій модуль `fileparse` і отримати допомогу щодо нього.
```python
>>> import fileparse
>>> help(fileparse)
... look at the output ...
>>> dir(fileparse)
... look at the output ...
>>>
```

Спробуйте скористатися модулем для читання даних:
```python
>>> portfolio = fileparse.parse_csv('Data/portfolio.csv',select=['name','shares','price'], types=[str,int,float])
>>> portfolio
... look at the output ...
>>> pricelist = fileparse.parse_csv('Data/prices.csv',types=[str,float], has_headers=False)
>>> pricelist
... look at the output ...
>>> prices = dict(pricelist)
>>> prices
... look at the output ...
>>> prices['IBM']
106.11
>>>
```

Спробуйте імпортувати функцію, щоб вам не потрібно було включати назву модуля:
```python
>>> from fileparse import parse_csv
>>> portfolio = parse_csv('Data/portfolio.csv', select=['name','shares','price'], types=[str,int,float])
>>> portfolio
... look at the output ...
>>>
```

### Вправа 3.12: Використання бібліотечного модуля

У розділі 2 ви написали програму `report.py`, яка створила такий звіт про акції:

```
      Name     Shares      Price     Change
---------- ---------- ---------- ----------
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
```

Візьміть цю програму та змініть її так, щоб уся обробка вхідного файлу здійснювалася за допомогою функцій у вашому модулі `fileparse`. Для цього імпортуйте `fileparse` як модуль і змініть функції `read_portfolio()` і `read_prices()` на використання функції `parse_csv()`.

Використовуйте інтерактивний приклад на початку цієї вправи як посібник. Після цього ви повинні отримати точно такий самий вихід, як і раніше.

### Вправа 3.14: Використання додаткових імпортів бібліотеки

У розділі 1 ви написали програму `pcost.py`, яка читала портфоліо та обчислювала його вартість.

```python
>>> import pcost
>>> pcost.portfolio_cost('Data/portfolio.csv')
44671.15
>>>
```

Змініть файл `pcost.py`, щоб він використовував функцію `report.read_portfolio()`.

### Коментар

Коли ви закінчите цю вправу, у вас повинно бути три програми. `fileparse.py`, який містить функцію загального призначення `parse_csv()`. `report.py`, який створює гарний звіт, але також містить функції `read_portfolio()` і `read_prices()`. І, нарешті, `pcost.py`, який обчислює вартість портфоліо, але використовує функцію `read_portfolio()`, написану для програми `report.py`.

[Зміст](../Contents.md) \| [Попередній розділ (3.3. Перевірка помилок)](03_Error_checking.md) \| [Наступний розділ (3.5. Основний модуль)](05_Main_module.md)
