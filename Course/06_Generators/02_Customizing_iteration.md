[Зміст](../Contents.md) \| [Попередній розділ (6.1 Протокол ітерації)](01_Iteration_protocol.md) \| [Наступний розділ (6.3 Проблеми виробника/споживача та робочі процеси)](03_Producers_consumers.md)

# 6.2 Налаштування ітерації

У цьому розділі розглядається, як можна налаштувати ітерацію за допомогою функції генератора.

### Проблема

Припустімо, ви хочете створити свій власний ітераційний шаблон.

Наприклад, зворотний відлік.

```python
>>> for x in countdown(10):
...   print(x, end=' ')
...
10 9 8 7 6 5 4 3 2 1
>>>
```

Для цього є простий спосіб.

### Генератори

Генератор — це функція, яка визначає ітерацію.

```python
def countdown(n):
    while n > 0:
        yield n
        n -= 1
```

Наприклад:

```python
>>> for x in countdown(10):
...   print(x, end=' ')
...
10 9 8 7 6 5 4 3 2 1
>>>
```

Генератор — це будь-яка функція, яка використовує оператор `yield`.

Поведінка генераторів відрізняється від звичайної функції. Виклик функції генератора створює об’єкт генератора. Він не виконує функцію негайно.

```python
def countdown(n):
    # Додано рядок про вивід
    print('Counting down from', n)
    while n > 0:
        yield n
        n -= 1
```

```python
>>> x = countdown(10)
# Виводу немає
>>> x
# x є об'єктом генератора
<generator object at 0x58490>
>>>
```

Функція виконується лише під час виклику `__next__()`.

```python
>>> x = countdown(10)
>>> x
<generator object at 0x58490>
>>> x.__next__()
Counting down from 10
10
>>>
```

`yield` створює значення, але призупиняє виконання функції.
Функція відновлює роботу після наступного виклику `__next__()`.

```python
>>> x.__next__()
9
>>> x.__next__()
8
```

Коли генератор нарешті повертається, ітерація викликає помилку.

```python
>>> x.__next__()
1
>>> x.__next__()
Traceback (most recent call last):
File "<stdin>", line 1, in ? StopIteration
>>>
```

*Спостереження: функція генератора реалізує той самий протокол низького рівня, який використовує оператор for для списків, кортежів, dicts, файлів тощо.*

## Вправи

### Вправа 6.4: Простий генератор

Якщо вам колись захочеться налаштувати ітерацію, вам завжди слід думати про функції генератора. Їх легко написати --- створіть функцію, яка виконує бажану логіку ітерації, і використовуйте `yield` для видачі значень.

Наприклад, спробуйте цей генератор, який шукає у файлі рядки, що містять відповідний підрядок:

```python
>>> def filematch(filename, substr):
        with open(filename, 'r') as f:
            for line in f:
                if substr in line:
                    yield line

>>> for line in open('Data/portfolio.csv'):
        print(line, end='')

name,shares,price
"AA",100,32.20
"IBM",50,91.10
"CAT",150,83.44
"MSFT",200,51.23
"GE",95,40.37
"MSFT",50,65.10
"IBM",100,70.44
>>> for line in filematch('Data/portfolio.csv', 'IBM'):
        print(line, end='')

"IBM",50,91.10
"IBM",100,70.44
>>>
```

Це начебто цікаво — ідея, що ви можете приховати купу нестандартної обробки у функції та використовувати її для живлення циклу for. Наступний приклад розглядає більш незвичайний випадок.

### Вправа 6.5: Моніторинг джерела потокових даних

Генератори можуть бути цікавим способом моніторингу джерел даних у реальному часі, таких як файли журналів або канали фондового ринку. У цій частині ми розглянемо цю ідею. Щоб почати, уважно дотримуйтеся наступних інструкцій.

Програма `Data/stocksim.py` — це програма, яка моделює дані фондового ринку. На виході програма постійно записує дані реального часу у файл `Data/stocklog.csv`. 

В окремому командному вікні перейдіть до каталогу `Data/` і запустіть цю програму:

```bash
bash % python3 stocksim.py
```

Якщо ви використовуєте Windows, просто знайдіть програму `stocksim.py` і двічі клацніть її, щоб запустити її. Тепер забудьте про цю програму (просто дайте їй працювати). В іншому вікні перегляньте файл `Data/stocklog.csv`, який записує симулятор. Ви повинні бачити нові рядки тексту, які додаються до файлу кожні кілька секунд. Знову ж таки, просто дайте цій програмі працювати у фоновому режимі --- вона працюватиме протягом кількох годин (вам не потрібно про це турбуватися).

Після того, як програма вище запущена, давайте напишемо невелику програму, щоб відкрити файл, перейти до кінця та спостерігати за новими результатами. Створіть файл `follow.py` і вставте в нього цей код:

```python
# follow.py
import os
import time

f = open('Data/stocklog.csv')
f.seek(0, os.SEEK_END)   # Перемістити вказівник файлу на 0 байтів від кінця файлу

while True:
    line = f.readline()
    if line == '':
        time.sleep(0.1)   # Недовго поспати та повторити спробу
        continue
    fields = line.split(',')
    name = fields[0].strip('"')
    price = float(fields[1])
    change = float(fields[4])
    if change < 0:
        print(f'{name:>10s} {price:>10.2f} {change:>10.2f}')
```

Якщо ви запустите програму, ви побачите біржовий тикер у реальному часі. Під капотом цей код схожий на команду Unix `tail -f`, яка використовується для перегляду файлу журналу.

Примітка. Використання методу `readline()` у цьому прикладі є дещо незвичним, оскільки це не звичайний спосіб читання рядків із файлу (зазвичай ви використовуєте лише цикл `for`). Однак у цьому випадку ми використовуємо його, щоб неодноразово перевіряти кінець файлу, щоб побачити, чи було додано більше даних (`readline()` поверне нові дані або порожній рядок).

### Вправа 6.6: Використання генератора для створення даних

Якщо ви подивитеся на код у вправі 6.5, перша частина коду створює рядки даних, тоді як оператори в кінці циклу `while` споживають дані. Основна особливість функцій генератора полягає в тому, що ви можете перемістити весь код виробництва даних у функцію для повторного використання.

Змініть код у вправі 6.5 так, щоб читання файлу виконувалося функцією генератора `follow(filename)`. Зробіть так, щоб наступний код працював:

```python
>>> for line in follow('Data/stocklog.csv'):
          print(line, end='')

... Маєте бачити рядки вихідних даних, створені тут ...
```

Змініть біржовий код, щоб він виглядав так:


```python
if __name__ == '__main__':
    for line in follow('Data/stocklog.csv'):
        fields = line.split(',')
        name = fields[0].strip('"')
        price = float(fields[1])
        change = float(fields[4])
        if change < 0:
            print(f'{name:>10s} {price:>10.2f} {change:>10.2f}')
```

### Вправа 6.7: Перегляд вашого портфоліо

Змініть програму `follow.py`, щоб вона спостерігала за потоком даних про акції та друкувала тікер, який показує інформацію лише для тих акцій у портфелі. Наприклад:

```python
if __name__ == '__main__':
    import report

    portfolio = report.read_portfolio('Data/portfolio.csv')

    for line in follow('Data/stocklog.csv'):
        fields = line.split(',')
        name = fields[0].strip('"')
        price = float(fields[1])
        change = float(fields[4])
        if name in portfolio:
            print(f'{name:>10s} {price:>10.2f} {change:>10.2f}')
```

Примітка: щоб це працювало, ваш клас `Portfolio` має підтримувати оператор `in`. Перегляньте [Вправа 6.3](01_Iteration_protocol) і переконайтеся, що ви застосовуєте оператор `__contains__()`.

### Обговорення

Щойно тут сталося щось дуже потужне. Ви перемістили цікавий шаблон ітерації (читання рядків у кінці файлу) у власну маленьку функцію. Функція `follow()` тепер є цією утилітою загального призначення, яку можна використовувати в будь-якій програмі. Наприклад, ви можете використовувати його для перегляду журналів сервера, журналів налагодження та інших подібних джерел даних. Це якось круто.

[Зміст](../Contents.md) \| [Попередній розділ (6.1 Протокол ітерації)](01_Iteration_protocol.md) \| [Наступний розділ (6.3 Проблеми виробника/споживача та робочі процеси)](03_Producers_consumers.md)