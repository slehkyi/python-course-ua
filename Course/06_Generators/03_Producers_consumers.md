[Зміст](../Contents.md) \| [Попередній розділ (6.2 Налаштування ітерації)](02_Customizing_iteration.md) \| [Наступний розділ (6.4 Вирази генераторів)](04_More_generators.md)

# 6.3 Виробники, споживачі та трубопроводи (так, трубопроводи)

Генератори є корисним інструментом для встановлення різноманітних проблем виробника/споживача та конвеєрів потоку даних. У цьому розділі це обговоримо.

### Проблеми виробник-споживач

Генератори тісно пов'язані з різними формами проблем *виробник-споживач*.

```python
# Продюсер/виробник
def follow(f):
    ...
    while True:
        ...
        yield line        # Видає значення `рядок` нижче
        ...

# Споживач
for line in follow(f):    # Споживає значення з `yield` вище
    ...
```

`yield` створює значення, які споживає `for`.

### Генераторні трубопроводи

Ви можете використовувати цей аспект генераторів для налаштування потоків обробки (наприклад, потоків (труб) Unix).

*виробник* &rarr; *обробка* &rarr; *обробка* &rarr; *споживач*

Труби обробки мають початковий виробник даних, деякий набір проміжних етапів обробки та кінцевого споживача.

**виробник** &rarr; *обробка* &rarr; *обробка* &rarr; *споживач*

```python
def producer():
    ...
    yield item
    ...
```

Виробником зазвичай є генератор. Хоча це також може бути список іншої послідовності. `yield` передає дані в потік (трубу).

*виробник* &rarr; *обробка* &rarr; *обробка* &rarr; **споживач**

```python
def consumer(s):
    for item in s:
        ...
```

Споживач — це цикл for. Він отримує елементи та щось з ними робить.

*виробник* &rarr; **обробка** &rarr; **обробка** &rarr; *споживач*

```python
def processing(s):
    for item in s:
        ...
        yield newitem
        ...
```

Проміжні етапи обробки одночасно споживають і виробляють предмети. Вони можуть змінити потік даних. Вони також можуть фільтрувати (відкидаючи елементи).

*виробник* &rarr; *обробка* &rarr; *обробка* &rarr; *споживач*

```python
def producer():
    ...
    yield item          # дає елемент, отриманий `обробкою`
    ...

def processing(s):
    for item in s:      # приходить від `виробника`
        ...
        yield newitem   # дає новий елемент
        ...

def consumer(s):
    for item in s:      # приходить від `обробки`
        ...
```

Код для налаштування труби

```python
a = producer()
b = processing(a)
c = consumer(b)
```

Ви помітите, що дані поступово проходять через різні функції.

## Вправи

Для цієї вправи програма `stocksim.py` все ще має працювати у фоновому режимі. Ви збираєтеся використовувати функцію `follow()`, написану в попередній вправі.

### Вправа 6.8: Налаштування простого конвеєра

Давайте подивимося на ідею конвеєрної обробки в дії. Напишіть таку функцію:

```python
>>> def filematch(lines, substr):
        for line in lines:
            if substr in line:
                yield line

>>>
```

Ця функція майже повністю така ж, як перший приклад генератора в попередній вправі, за винятком того, що вона більше не відкриває файл – вона просто працює з послідовністю рядків, наданих їй як аргумент. Тепер спробуйте це:

```
>>> from follow import follow
>>> lines = follow('Data/stocklog.csv')
>>> ibm = filematch(lines, 'IBM')
>>> for line in ibm:
        print(line)

... дочекатися виведення ...
```

Може знадобитися деякий час, перш ніж з’явиться результат, але згодом ви побачите деякі рядки, що містять дані для IBM.

### Вправа 6.9: Налаштування більш складного конвеєра

Розвивайте ідею конвеєрної обробки на кілька кроків далі, виконуючи більше дій.

```
>>> from follow import follow
>>> import csv
>>> lines = follow('Data/stocklog.csv')
>>> rows = csv.reader(lines)
>>> for row in rows:
        print(row)

['BA', '98.35', '6/11/2007', '09:41.07', '0.16', '98.25', '98.35', '98.31', '158148']
['AA', '39.63', '6/11/2007', '09:41.07', '-0.03', '39.67', '39.63', '39.31', '270224']
['XOM', '82.45', '6/11/2007', '09:41.07', '-0.23', '82.68', '82.64', '82.41', '748062']
['PG', '62.95', '6/11/2007', '09:41.08', '-0.12', '62.80', '62.97', '62.61', '454327']
...
```

Ну, це цікаво. Тут ви бачите, що вихідні дані функції `follow()` були передані у функцію `csv.reader()`, і тепер ми отримуємо послідовність розділених рядків.

### Вправа 6.10: Створення додаткових компонентів трубопроводу

Давайте розширимо всю ідею в більший конвеєр/трубу. В окремому файлі `ticker.py` створіть функцію, яка читає файл CSV, як ви робили вище:

```python
# ticker.py

from follow import follow
import csv

def parse_stock_data(lines):
    rows = csv.reader(lines)
    return rows

if __name__ == '__main__':
    lines = follow('Data/stocklog.csv')
    rows = parse_stock_data(lines)
    for row in rows:
        print(row)
```

Напишіть нову функцію, яка вибирає певні стовпці:

```python
# ticker.py
...
def select_columns(rows, indices):
    for row in rows:
        yield [row[index] for index in indices]
...
def parse_stock_data(lines):
    rows = csv.reader(lines)
    rows = select_columns(rows, [0, 1, 4])
    return rows
```

Запустіть програму ще раз. Ви повинні побачити вихідні дані, звужені таким чином:

```
['BA', '98.35', '0.16']
['AA', '39.63', '-0.03']
['XOM', '82.45','-0.23']
['PG', '62.95', '-0.12']
...
```

Напишіть функції генератора, які перетворюють типи даних і створюють словники. Наприклад:

```python
# ticker.py
...

def convert_types(rows, types):
    for row in rows:
        yield [func(val) for func, val in zip(types, row)]

def make_dicts(rows, headers):
    for row in rows:
        yield dict(zip(headers, row))
...
def parse_stock_data(lines):
    rows = csv.reader(lines)
    rows = select_columns(rows, [0, 1, 4])
    rows = convert_types(rows, [str, float, float])
    rows = make_dicts(rows, ['name', 'price', 'change'])
    return rows
...
```

Запустіть програму ще раз. Тепер у вас має бути такий потік словників:

```
{ 'name':'BA', 'price':98.35, 'change':0.16 }
{ 'name':'AA', 'price':39.63, 'change':-0.03 }
{ 'name':'XOM', 'price':82.45, 'change': -0.23 }
{ 'name':'PG', 'price':62.95, 'change':-0.12 }
...
```

### Вправа 6.11: Фільтрування даних

Напишіть функцію, яка фільтрує дані. Наприклад:

```python
# ticker.py
...

def filter_symbols(rows, names):
    for row in rows:
        if row['name'] in names:
            yield row
```

Використовуйте це, щоб фільтрувати акції лише до тих, що є у вашому портфелі:

```python
import report
portfolio = report.read_portfolio('Data/portfolio.csv')
rows = parse_stock_data(follow('Data/stocklog.csv'))
rows = filter_symbols(rows, portfolio)
for row in rows:
    print(row)
```

### Вправа 6.12: Збираємо все разом

У програмі `ticker.py` напишіть функцію `ticker(portfile, logfile, fmt)`, яка створює біржовий тикер у реальному часі з певного портфоліо, файла журналу та формату таблиці. Наприклад:

```python
>>> from ticker import ticker
>>> ticker('Data/portfolio.csv', 'Data/stocklog.csv', 'txt')
      Name      Price     Change
---------- ---------- ----------
        GE      37.14      -0.18
      MSFT      29.96      -0.09
       CAT      78.03      -0.49
        AA      39.34      -0.32
...

>>> ticker('Data/portfolio.csv', 'Data/stocklog.csv', 'csv')
Name,Price,Change
IBM,102.79,-0.28
CAT,78.04,-0.48
AA,39.35,-0.31
CAT,78.05,-0.47
...
```

### Обговорення

Деякі отримані уроки: ви можете створювати різні функції генератора та об’єднувати їх для виконання обробки за допомогою конвеєрів потоку даних. Крім того, ви можете створювати функції, які упаковують серію етапів конвеєра в один виклик функції (наприклад, функція `parse_stock_data()`).

[Зміст](../Contents.md) \| [Попередній розділ (6.2 Налаштування ітерації)](02_Customizing_iteration.md) \| [Наступний розділ (6.4 Вирази генераторів)](04_More_generators.md)