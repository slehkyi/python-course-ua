[Зміст](../Contents.md) \| [Попередній розділ (6.3 Проблеми виробника/споживача та робочі процеси)](03_Producers_consumers.md) \| [Наступна частина (7. Складніші теми)](../07_Advanced_topics/00_Overview.md)

# 6.4 Більше генераторів

У цьому розділі представлено кілька додаткових тем, пов’язаних із генераторами, включаючи вирази генератора та модуль `itertools`.

### Генератор виразів

Компрехенція списку у версії генератора.

```python
>>> a = [1,2,3,4]
>>> b = (2*x for x in a)
>>> b
<generator object at 0x58760>
>>> for i in b:
...   print(i, end=' ')
...
2 4 6 8
>>>
```

Відмінності від компрехенції списків.

* Не створює списку.
* Єдиною корисною метою є ітерація.
* Після споживання не можна використати повторно.

Загальний синтаксис.

```python
(<expression> for i in s if <conditional>)
```

Він також може служити аргументом функції.

```python
sum(x*x for x in a)
```

Його можна застосувати до будь-якого ітерованого.

```python
>>> a = [1,2,3,4]
>>> b = (x*x for x in a)
>>> c = (-x for x in b)
>>> for i in c:
...   print(i, end=' ')
...
-1 -4 -9 -16
>>>
```

Вирази-генератори використовуються в основному в коді, який виконує деякі обчислення в послідовності, але використовує результат лише один раз. Наприклад, видалити всі коментарі з файлу.

```python
f = open('somefile.txt')
lines = (line for line in f if not line.startswith('#'))
for line in lines:
    ...
f.close()
```

За допомогою генераторів код працює швидше та використовує мало пам’яті. Це як фільтр, застосований до потоку.

### Чому генератори

* Багато проблем набагато чіткіше виражені в термінах ітерації.
   * Перегляд колекції елементів і виконання певної операції (пошук, заміна, зміна тощо).
   * Конвеєри обробки можуть бути застосовані до широкого кола проблем обробки даних.
* Краща ефективність пам'яті.
   * Створення значень лише за потреби.
   * На відміну від побудови гігантських списків.
   * Може працювати з потоковими даними
* Генератори заохочують повторне використання коду
   * Відокремлює *ітерацію* від коду, який використовує ітерацію
   * Ви можете створити набір інструментів цікавих ітераційних функцій і *mix-n-match*.

### Модуль `itertools`

`itertools` — це модуль бібліотеки з різними функціями, призначеними для допомоги при роботі з ітераторами/генераторами.

```python
itertools.chain(s1,s2)
itertools.count(n)
itertools.cycle(s)
itertools.dropwhile(predicate, s)
itertools.groupby(s)
itertools.ifilter(predicate, s)
itertools.imap(function, s1, ... sN)
itertools.repeat(s, n)
itertools.tee(s, ncopies)
itertools.izip(s1, ... , sN)
```

Усі функції обробляють дані ітеративно. Вони реалізують різні види ітераційних шаблонів.

Більше інформації див. у посібнику [Генераторні прийоми для системних програмістів](http://www.dabeaz.com/generators/) від PyCon '08.

## Вправи

У попередніх вправах ви написали деякий код, який слідував за рядками, записаними у файл журналу, і аналізував їх на послідовність рядків. Ця вправа продовжує спиратися на це. Переконайтеся, що `Data/stocksim.py` все ще працює.

### Вправа 6.13: Генератор виразів

Вирази генератора є версією генератора компрехенції списку. Наприклад:

```python
>>> nums = [1, 2, 3, 4, 5]
>>> squares = (x*x for x in nums)
>>> squares
<generator object <genexpr> at 0x109207e60>
>>> for n in squares:
...     print(n)
...
1
4
9
16
25
```

На відміну від списку розуміння, вираз генератора можна використовувати лише один раз. Таким чином, якщо ви спробуєте інший цикл `for`, ви нічого не отримаєте:

```python
>>> for n in squares:
...     print(n)
...
>>>
```

### Вправа 6.14: Вирази генератора в аргументах функції

Вирази генератора іноді поміщаються в аргументи функції. Спочатку це виглядає трохи дивно, але спробуйте цей експеримент:

```python
>>> nums = [1,2,3,4,5]
>>> sum([x*x for x in nums])    # компрехенція списку
55
>>> sum(x*x for x in nums)      # генератор
55
>>>
```
У наведеному вище прикладі друга версія, яка використовує генератори, використовує значно менше пам’яті, особливо якщо список великий.

У вашому файлі `portfolio.py` ви виконали кілька обчислень із використанням списків. Спробуйте замінити їх виразами-генераторами.

### Вправа 6.15: Спрощення коду

Вирази генераторів часто є корисною заміною для невеликих генераторних функцій. Наприклад, замість написання такої функції:

```python
def filter_symbols(rows, names):
    for row in rows:
        if row['name'] in names:
            yield row
```

Ви можете написати щось на зразок цього:

```python
rows = (row for row in rows if row['name'] in names)
```

Змініть програму `ticker.py`, щоб відповідно використовувати вирази генератора.

[Зміст](../Contents.md) \| [Попередній розділ (6.3 Проблеми виробника/споживача та робочі процеси)](03_Producers_consumers.md) \| [Наступна частина (7. Складніші теми)](../07_Advanced_topics/00_Overview.md)